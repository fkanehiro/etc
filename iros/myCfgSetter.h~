#include <Model/HumanoidBodyUtil.h>

class myCfgSetter
{
public:
  myCfgSetter(motion_generator::HumanoidBodyPtr i_body, int i_arm)
        : m_body(i_body){
        m_arm = m_body->getJointPath(m_body->chestLink,
                                     m_body->wristLink[i_arm]);
        for (int i=0; i<2; i++){
            m_leg[i] = m_body->getJointPath(m_body->rootLink(),
                                            m_body->ankleLink[i]);
            m_footP[i] = m_body->ankleLink[i]->p;
            m_footR[i] = m_body->ankleLink[i]->R;
        }
        m_cog = m_body->calcCM();
        m_cog2waist = m_body->rootLink()->p - m_cog;
        for (int i=0; i<2; i++){
            m_ikFailCount[i] = 0;
        }
        m_nCalls = 0;
    }
    bool set(PathEngine::PathPlanner *i_planner,
             const PathEngine::Configuration &i_cfg){
        m_nCalls++;
        m_body->rootLink()->R = hrp::rotFromRpy(i_cfg[1],i_cfg[2],i_cfg[3]);
        m_body->rootLink()->p = m_cog + m_body->rootLink()->R*m_cog2waist;
        m_body->rootLink()->p[2] = i_cfg[0];
        for (int i=0; i<m_arm->numJoints(); i++){
            hrp::Link *j = m_arm->joint(i);
            j->q = i_cfg[4+i];
        }
        for (int i=0; i<2; i++){ 
            if (!m_leg[i]->calcInverseKinematics(m_footP[i], m_footR[i])){
                m_ikFailCount[i]++; 
                return false;
            }
        }
        m_body->calcForwardKinematics();
        return true;
    }
    void profile(){
        std::cout << m_nCalls << " times called( ";
        for (int i=0; i<2; i++) std::cout << m_ikFailCount[i] << " ";
        std::cout << ")" << std::endl;
    }
private:
    motion_generator::HumanoidBodyPtr m_body;
    int m_ikFailCount[2], m_nCalls;
    hrp::JointPathPtr m_arm, m_leg[2];
    hrp::Vector3 m_footP[2], m_cog, m_cog2waist;
    hrp::Matrix33 m_footR[2];
};
