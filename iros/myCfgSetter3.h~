#include <Math/MathFunction.h>
#include "cfgSetterBase.h"

class myCfgSetter : public cfgSetterBase
{
public:
    myCfgSetter(motion_generator::HumanoidBodyPtr i_body, int i_arm,
                const hrp::Vector3 &i_goalP)
        : cfgSetterBase(i_body), m_goalP(i_goalP){
        m_arm = m_body->getJointPath(m_body->chestLink,
                                     m_body->wristLink[i_arm]);
        m_trunk = m_body->getJointPath(m_body->rootLink(), m_body->chestLink);
        for (int i=0; i<3; i++){
            m_ikFailCount[i] = 0;
        }
    }
    bool set(PathEngine::PathPlanner *i_planner,
             const PathEngine::Configuration &i_cfg){
        setBase(i_cfg[0], i_cfg[1], i_cfg[2], i_cfg[3]);
        m_trunk->calcForwardKinematics();

        hrp::Matrix33 bulbR = hrp::rotFromPitch(-M_PI/2);
        hrp::Matrix33 R = hrp::rotFromRpy(i_cfg[4], i_cfg[5], i_cfg[6]); 
        hrp::Matrix33 wristR(bulbR*R);

        hrp::Vector3 wristP(m_goalP + wristR*hrp::Vector3(-0.03,0,0.18));
        if (!m_arm->calcInverseKinematics(wristP, wristR)) {
            m_ikFailCount[0]++;
            return false;
        }
        // check joint limits
        for (int i=0; i<m_arm->numJoints(); i++){
            hrp::Link *j = m_arm->joint(i);
            if (j->q > j->ulimit || j->q < j->llimit){
                m_ikFailCount[0]++;
                return false;
            }
        }
        for (int i=0; i<2; i++){ 
            if (!m_leg[i]->calcInverseKinematics(m_footP[i], m_footR[i])){
                m_ikFailCount[i+1]++; 
                return false;
            }
            // check joint limits
            for (int k=0; k<m_leg[i]->numJoints(); k++){
                hrp::Link *j = m_leg[i]->joint(k);
                if (j->q > j->ulimit || j->q < j->llimit){
                    m_ikFailCount[i+1]++;
                    return false;
                }
            }
        }
        m_body->calcForwardKinematics();
        return true;
    }
    void profile(){
        for (int i=0; i<3; i++) std::cout << m_ikFailCount[i] << " ";
        std::cout << std::endl;
    }
private:
    int m_ikFailCount[3];
    hrp::JointPathPtr m_arm, m_trunk;
    hrp::Vector3 m_goalP;
};
