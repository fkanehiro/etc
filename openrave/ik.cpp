/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2016-02-08 15:44:01.928165
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38;
x0=IKsin(j[0]);
x1=IKcos(j[2]);
x2=IKsin(j[1]);
x3=IKcos(j[0]);
x4=IKsin(j[2]);
x5=IKcos(j[3]);
x6=IKcos(j[1]);
x7=IKsin(j[3]);
x8=IKsin(j[4]);
x9=IKcos(j[4]);
x10=IKcos(j[5]);
x11=IKsin(j[5]);
x12=((1.0)*x5);
x13=((0.25)*x6);
x14=((1.0)*x7);
x15=((1.0)*x3);
x16=((0.25)*x3);
x17=((1.0)*x0);
x18=((0.25)*x0);
x19=(x5*x6);
x20=(x1*x2);
x21=(x4*x7);
x22=(x2*x5);
x23=(x0*x1);
x24=(x2*x4);
x25=(x1*x6);
x26=(x0*x14*x6);
x27=(x0*x12*x6);
x28=(x14*x4*x6);
x29=(x15*x24);
x30=(((x1*x3))+((x0*x24)));
x31=(((x0*x20))+(((-1.0)*x15*x4)));
x32=((((-1.0)*x1*x17))+x29);
x33=((((-1.0)*x1*x15))+(((-1.0)*x17*x24)));
x34=(((x17*x4))+((x15*x20)));
x35=(((x25*x8))+((x9*((((x19*x4))+((x2*x7)))))));
x36=(((x5*(((((-1.0)*x29))+x23))))+((x3*x6*x7)));
x37=(((x31*x8))+((x9*((((x30*x5))+(((-1.0)*x26)))))));
x38=((((-1.0)*x36*x9))+(((1.0)*x34*x8)));
eerot[0]=(((x10*x37))+((x11*(((((-1.0)*x27))+((x33*x7)))))));
eerot[1]=(((x31*x9))+((x8*(((((-1.0)*x12*x30))+x26)))));
eerot[2]=(((x11*x37))+((x10*(((((-1.0)*x14*x33))+x27)))));
IkReal x39=((1.0)*x0*x13);
eetrans[0]=((0.008)+(((-1.0)*x39))+(((-1.0)*x39*x5))+((x7*(((((-1.0)*x1*x16))+(((-1.0)*x18*x24)))))));
eerot[3]=(((x10*x35))+((x11*(((((-1.0)*x28))+x22)))));
eerot[4]=(((x8*(((((-1.0)*x14*x2))+(((-1.0)*x12*x4*x6))))))+((x25*x9)));
eerot[5]=(((x10*(((((-1.0)*x12*x2))+x28))))+((x11*x35)));
eetrans[1]=((-0.25)+(((-1.0)*x13*x21))+(((0.25)*x22))+(((0.25)*x2)));
eerot[6]=(((x10*x38))+((x11*(((((-1.0)*x14*x32))+(((-1.0)*x12*x3*x6)))))));
eerot[7]=(((x34*x9))+((x36*x8)));
eerot[8]=(((x11*x38))+((x10*((((x32*x7))+((x19*x3)))))));
IkReal x40=((1.0)*x13*x3);
eetrans[2]=((0.181)+(((-1.0)*x40))+(((-1.0)*x40*x5))+((x7*((((x1*x18))+(((-1.0)*x16*x24)))))));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j16,cj16,sj16,htj16,j16mul,j17,cj17,sj17,htj17,j17mul,j18,cj18,sj18,htj18,j18mul,j19,cj19,sj19,htj19,j19mul,j20,cj20,sj20,htj20,j20mul,j21,cj21,sj21,htj21,j21mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij16[2], _nj16,_ij17[2], _nj17,_ij18[2], _nj18,_ij19[2], _nj19,_ij20[2], _nj20,_ij21[2], _nj21;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j16=numeric_limits<IkReal>::quiet_NaN(); _ij16[0] = -1; _ij16[1] = -1; _nj16 = -1; j17=numeric_limits<IkReal>::quiet_NaN(); _ij17[0] = -1; _ij17[1] = -1; _nj17 = -1; j18=numeric_limits<IkReal>::quiet_NaN(); _ij18[0] = -1; _ij18[1] = -1; _nj18 = -1; j19=numeric_limits<IkReal>::quiet_NaN(); _ij19[0] = -1; _ij19[1] = -1; _nj19 = -1; j20=numeric_limits<IkReal>::quiet_NaN(); _ij20[0] = -1; _ij20[1] = -1; _nj20 = -1; j21=numeric_limits<IkReal>::quiet_NaN(); _ij21[0] = -1; _ij21[1] = -1; _nj21 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=((-1.0)*r02);
new_r02=r01;
new_px=((-0.008)+px);
new_r10=((-1.0)*r20);
new_r11=r22;
new_r12=((-1.0)*r21);
new_py=((0.181)+(((-1.0)*pz)));
new_r20=r10;
new_r21=((-1.0)*r12);
new_r22=r11;
new_pz=((0.25)+py);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x41=((1.0)*px);
IkReal x42=((1.0)*pz);
IkReal x43=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x43))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x42)));
rxp0_2=((((-1.0)*r10*x41))+((py*r00)));
rxp1_0=((((-1.0)*r21*x43))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x42)));
rxp1_2=((((-1.0)*r11*x41))+((py*r01)));
rxp2_0=((((-1.0)*r22*x43))+((pz*r12)));
rxp2_1=((((-1.0)*r02*x42))+((px*r22)));
rxp2_2=((((-1.0)*r12*x41))+((py*r02)));
{
IkReal j19array[2], cj19array[2], sj19array[2];
bool j19valid[2]={false};
_nj19 = 2;
cj19array[0]=((-1.0)+(((8.0)*pp)));
if( cj19array[0] >= -1-IKFAST_SINCOS_THRESH && cj19array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j19valid[0] = j19valid[1] = true;
    j19array[0] = IKacos(cj19array[0]);
    sj19array[0] = IKsin(j19array[0]);
    cj19array[1] = cj19array[0];
    j19array[1] = -j19array[0];
    sj19array[1] = -sj19array[0];
}
else if( isnan(cj19array[0]) )
{
    // probably any value will work
    j19valid[0] = true;
    cj19array[0] = 1; sj19array[0] = 0; j19array[0] = 0;
}
for(int ij19 = 0; ij19 < 2; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 2; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];

{
IkReal j21eval[2];
j21eval[0]=((IKabs(npy))+(IKabs(npx)));
j21eval[1]=((npx*npx)+(npy*npy));
if( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  )
{
{
IkReal j20eval[1];
j20eval[0]=sj19;
if( IKabs(j20eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j20, j21]

} else
{
{
IkReal j20array[2], cj20array[2], sj20array[2];
bool j20valid[2]={false};
_nj20 = 2;
CheckValue<IkReal> x44=IKPowWithIntegerCheck(sj19,-1);
if(!x44.valid){
continue;
}
sj20array[0]=((-4.0)*npz*(x44.value));
if( sj20array[0] >= -1-IKFAST_SINCOS_THRESH && sj20array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j20valid[0] = j20valid[1] = true;
    j20array[0] = IKasin(sj20array[0]);
    cj20array[0] = IKcos(j20array[0]);
    sj20array[1] = sj20array[0];
    j20array[1] = j20array[0] > 0 ? (IKPI-j20array[0]) : (-IKPI-j20array[0]);
    cj20array[1] = -cj20array[0];
}
else if( isnan(sj20array[0]) )
{
    // probably any value will work
    j20valid[0] = true;
    cj20array[0] = 1; sj20array[0] = 0; j20array[0] = 0;
}
for(int ij20 = 0; ij20 < 2; ++ij20)
{
if( !j20valid[ij20] )
{
    continue;
}
_ij20[0] = ij20; _ij20[1] = -1;
for(int iij20 = ij20+1; iij20 < 2; ++iij20)
{
if( j20valid[iij20] && IKabs(cj20array[ij20]-cj20array[iij20]) < IKFAST_SOLUTION_THRESH && IKabs(sj20array[ij20]-sj20array[iij20]) < IKFAST_SOLUTION_THRESH )
{
    j20valid[iij20]=false; _ij20[1] = iij20; break; 
}
}
j20 = j20array[ij20]; cj20 = cj20array[ij20]; sj20 = sj20array[ij20];

{
IkReal j21eval[3];
IkReal x45=npy*npy;
IkReal x46=npx*npx;
IkReal x47=(cj20*sj19);
j21eval[0]=(x46+x45);
j21eval[1]=((IKabs((npx+((cj19*npx))+(((-1.0)*npy*x47)))))+(IKabs((npy+((npx*x47))+((cj19*npy))))));
j21eval[2]=IKsign(((((4.0)*x46))+(((4.0)*x45))));
if( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  || IKabs(j21eval[2]) < 0.0000010000000000  )
{
{
IkReal j21eval[3];
IkReal x48=(cj20*npz);
IkReal x49=((0.25)*sj20);
IkReal x50=(((sj20*(npx*npx)))+((sj20*(npy*npy))));
j21eval[0]=x50;
j21eval[1]=IKsign(x50);
j21eval[2]=((IKabs(((((-1.0)*npx*x48))+((npy*x49))+((cj19*npy*x49)))))+(IKabs((((npy*x48))+((npx*x49))+((cj19*npx*x49))))));
if( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  || IKabs(j21eval[2]) < 0.0000010000000000  )
{
{
IkReal j21eval[3];
IkReal x51=((0.25)*npx);
IkReal x52=(npz*sj20);
IkReal x53=(cj19*cj20);
IkReal x54=((0.25)*npy);
IkReal x55=(((cj20*(npx*npx)))+((cj20*(npy*npy))));
j21eval[0]=x55;
j21eval[1]=IKsign(x55);
j21eval[2]=((IKabs((((cj20*x54))+((npx*x52))+((x53*x54))+((sj19*x51)))))+(IKabs((((cj20*x51))+(((-1.0)*npy*x52))+((x51*x53))+(((-1.0)*sj19*x54))))));
if( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  || IKabs(j21eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j20)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j21eval[3];
sj20=1.0;
cj20=0;
j20=1.5707963267949;
IkReal x56=((npx*npx)+(npy*npy));
j21eval[0]=x56;
j21eval[1]=((IKabs((npy+((cj19*npy)))))+(IKabs((npx+((cj19*npx))))));
j21eval[2]=IKsign(x56);
if( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  || IKabs(j21eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959)));
evalcond[1]=pp;
evalcond[2]=npz;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j21eval[1];
sj20=1.0;
cj20=0;
j20=1.5707963267949;
sj19=0;
cj19=-1.0;
j19=3.14159265358979;
j21eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j21eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j21]

} else
{
{
IkReal j21array[2], cj21array[2], sj21array[2];
bool j21valid[2]={false};
_nj21 = 2;
CheckValue<IkReal> x58 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x58.valid){
continue;
}
IkReal x57=x58.value;
j21array[0]=((-1.0)*x57);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
j21array[1]=((3.14159265358979)+(((-1.0)*x57)));
sj21array[1]=IKsin(j21array[1]);
cj21array[1]=IKcos(j21array[1]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
if( j21array[1] > IKPI )
{
    j21array[1]-=IK2PI;
}
else if( j21array[1] < -IKPI )
{    j21array[1]+=IK2PI;
}
j21valid[1] = true;
for(int ij21 = 0; ij21 < 2; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 2; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npx*(IKsin(j21))))+(((-1.0)*npy*(IKcos(j21)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j21]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x830=((0.25)*npx);
IkReal x831=((0.25)*npy);
CheckValue<IkReal> x832 = IKatan2WithCheck(IkReal((x830+((cj19*x830)))),IkReal((x831+((cj19*x831)))),IKFAST_ATAN2_MAGTHRESH);
if(!x832.valid){
continue;
}
CheckValue<IkReal> x833=IKPowWithIntegerCheck(IKsign(((npx*npx)+(npy*npy))),-1);
if(!x833.valid){
continue;
}
j21array[0]=((-1.5707963267949)+(x832.value)+(((1.5707963267949)*(x833.value))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[2];
IkReal x834=IKcos(j21);
IkReal x835=IKsin(j21);
IkReal x836=((1.0)*x834);
evalcond[0]=((((-1.0)*npx*x836))+((npy*x835)));
evalcond[1]=((0.25)+(((-1.0)*npy*x836))+(((0.25)*cj19))+(((-1.0)*npx*x835)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j20)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j21eval[3];
sj20=-1.0;
cj20=0;
j20=-1.5707963267949;
IkReal x837=((npx*npx)+(npy*npy));
j21eval[0]=x837;
j21eval[1]=((IKabs((npy+((cj19*npy)))))+(IKabs((npx+((cj19*npx))))));
j21eval[2]=IKsign(x837);
if( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  || IKabs(j21eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959)));
evalcond[1]=pp;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j21eval[1];
sj20=-1.0;
cj20=0;
j20=-1.5707963267949;
sj19=0;
cj19=-1.0;
j19=3.14159265358979;
j21eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j21eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j21]

} else
{
{
IkReal j21array[2], cj21array[2], sj21array[2];
bool j21valid[2]={false};
_nj21 = 2;
CheckValue<IkReal> x839 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x839.valid){
continue;
}
IkReal x838=x839.value;
j21array[0]=((-1.0)*x838);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
j21array[1]=((3.14159265358979)+(((-1.0)*x838)));
sj21array[1]=IKsin(j21array[1]);
cj21array[1]=IKcos(j21array[1]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
if( j21array[1] > IKPI )
{
    j21array[1]-=IK2PI;
}
else if( j21array[1] < -IKPI )
{    j21array[1]+=IK2PI;
}
j21valid[1] = true;
for(int ij21 = 0; ij21 < 2; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 2; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npx*(IKsin(j21))))+(((-1.0)*npy*(IKcos(j21)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j21]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x840=((0.25)*npx);
IkReal x841=((0.25)*npy);
CheckValue<IkReal> x842 = IKatan2WithCheck(IkReal((x840+((cj19*x840)))),IkReal((x841+((cj19*x841)))),IKFAST_ATAN2_MAGTHRESH);
if(!x842.valid){
continue;
}
CheckValue<IkReal> x843=IKPowWithIntegerCheck(IKsign(((npx*npx)+(npy*npy))),-1);
if(!x843.valid){
continue;
}
j21array[0]=((-1.5707963267949)+(x842.value)+(((1.5707963267949)*(x843.value))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[2];
IkReal x844=IKcos(j21);
IkReal x845=IKsin(j21);
IkReal x846=((1.0)*x844);
evalcond[0]=((((-1.0)*npx*x846))+((npy*x845)));
evalcond[1]=((0.25)+(((-1.0)*npy*x846))+(((-1.0)*npx*x845))+(((0.25)*cj19)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j21eval[3];
sj20=0;
cj20=1.0;
j20=0;
IkReal x847=npy*npy;
IkReal x848=npx*npx;
j21eval[0]=(x847+x848);
j21eval[1]=((IKabs((npy+((cj19*npy))+((npx*sj19)))))+(IKabs((npx+((cj19*npx))+(((-1.0)*npy*sj19))))));
j21eval[2]=IKsign(((((4.0)*x848))+(((4.0)*x847))));
if( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  || IKabs(j21eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959)));
evalcond[1]=pp;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j21eval[1];
sj20=0;
cj20=1.0;
j20=0;
sj19=0;
cj19=-1.0;
j19=3.14159265358979;
j21eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j21eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j21]

} else
{
{
IkReal j21array[2], cj21array[2], sj21array[2];
bool j21valid[2]={false};
_nj21 = 2;
CheckValue<IkReal> x850 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x850.valid){
continue;
}
IkReal x849=x850.value;
j21array[0]=((-1.0)*x849);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
j21array[1]=((3.14159265358979)+(((-1.0)*x849)));
sj21array[1]=IKsin(j21array[1]);
cj21array[1]=IKcos(j21array[1]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
if( j21array[1] > IKPI )
{
    j21array[1]-=IK2PI;
}
else if( j21array[1] < -IKPI )
{    j21array[1]+=IK2PI;
}
j21valid[1] = true;
for(int ij21 = 0; ij21 < 2; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 2; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npx*(IKsin(j21))))+(((-1.0)*npy*(IKcos(j21)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j21]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x851=IKPowWithIntegerCheck(IKsign(((((4.0)*(npy*npy)))+(((4.0)*(npx*npx))))),-1);
if(!x851.valid){
continue;
}
CheckValue<IkReal> x852 = IKatan2WithCheck(IkReal((npx+((cj19*npx))+(((-1.0)*npy*sj19)))),IkReal((npy+((cj19*npy))+((npx*sj19)))),IKFAST_ATAN2_MAGTHRESH);
if(!x852.valid){
continue;
}
j21array[0]=((-1.5707963267949)+(((1.5707963267949)*(x851.value)))+(x852.value));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[2];
IkReal x853=IKcos(j21);
IkReal x854=IKsin(j21);
IkReal x855=((1.0)*x853);
evalcond[0]=((((-1.0)*npx*x855))+((npy*x854))+(((0.25)*sj19)));
evalcond[1]=((0.25)+(((0.25)*cj19))+(((-1.0)*npy*x855))+(((-1.0)*npx*x854)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)));
evalcond[1]=npz;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j21eval[3];
sj20=0;
cj20=-1.0;
j20=3.14159265358979;
IkReal x856=npy*npy;
IkReal x857=npx*npx;
j21eval[0]=(x856+x857);
j21eval[1]=((IKabs((npx+((cj19*npx))+((npy*sj19)))))+(IKabs((npy+((cj19*npy))+(((-1.0)*npx*sj19))))));
j21eval[2]=IKsign(((((4.0)*x857))+(((4.0)*x856))));
if( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  || IKabs(j21eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959)));
evalcond[1]=pp;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j21eval[1];
sj20=0;
cj20=-1.0;
j20=3.14159265358979;
sj19=0;
cj19=-1.0;
j19=3.14159265358979;
j21eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j21eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j21]

} else
{
{
IkReal j21array[2], cj21array[2], sj21array[2];
bool j21valid[2]={false};
_nj21 = 2;
CheckValue<IkReal> x859 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x859.valid){
continue;
}
IkReal x858=x859.value;
j21array[0]=((-1.0)*x858);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
j21array[1]=((3.14159265358979)+(((-1.0)*x858)));
sj21array[1]=IKsin(j21array[1]);
cj21array[1]=IKcos(j21array[1]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
if( j21array[1] > IKPI )
{
    j21array[1]-=IK2PI;
}
else if( j21array[1] < -IKPI )
{    j21array[1]+=IK2PI;
}
j21valid[1] = true;
for(int ij21 = 0; ij21 < 2; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 2; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npx*(IKsin(j21))))+(((-1.0)*npy*(IKcos(j21)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j21]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x860=IKPowWithIntegerCheck(IKsign(((((4.0)*(npy*npy)))+(((4.0)*(npx*npx))))),-1);
if(!x860.valid){
continue;
}
CheckValue<IkReal> x861 = IKatan2WithCheck(IkReal((npx+((cj19*npx))+((npy*sj19)))),IkReal((npy+((cj19*npy))+(((-1.0)*npx*sj19)))),IKFAST_ATAN2_MAGTHRESH);
if(!x861.valid){
continue;
}
j21array[0]=((-1.5707963267949)+(((1.5707963267949)*(x860.value)))+(x861.value));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[2];
IkReal x862=IKcos(j21);
IkReal x863=IKsin(j21);
IkReal x864=((1.0)*x862);
evalcond[0]=((((-0.25)*sj19))+(((-1.0)*npx*x864))+((npy*x863)));
evalcond[1]=((0.25)+(((0.25)*cj19))+(((-1.0)*npx*x863))+(((-1.0)*npy*x864)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959)));
evalcond[1]=pp;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j21eval[1];
sj19=0;
cj19=-1.0;
j19=3.14159265358979;
j21eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j21eval[0]) < 0.0000010000000000  )
{
{
IkReal j21eval[1];
sj19=0;
cj19=-1.0;
j19=3.14159265358979;
j21eval[0]=((IKabs((npx*sj20)))+(IKabs((npy*sj20))));
if( IKabs(j21eval[0]) < 0.0000010000000000  )
{
{
IkReal j21eval[1];
sj19=0;
cj19=-1.0;
j19=3.14159265358979;
j21eval[0]=((IKabs((cj20*npy)))+(IKabs((cj20*npx))));
if( IKabs(j21eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j21]

} else
{
{
IkReal j21array[2], cj21array[2], sj21array[2];
bool j21valid[2]={false};
_nj21 = 2;
CheckValue<IkReal> x866 = IKatan2WithCheck(IkReal(((-1.0)*cj20*npx)),IkReal((cj20*npy)),IKFAST_ATAN2_MAGTHRESH);
if(!x866.valid){
continue;
}
IkReal x865=x866.value;
j21array[0]=((-1.0)*x865);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
j21array[1]=((3.14159265358979)+(((-1.0)*x865)));
sj21array[1]=IKsin(j21array[1]);
cj21array[1]=IKcos(j21array[1]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
if( j21array[1] > IKPI )
{
    j21array[1]-=IK2PI;
}
else if( j21array[1] < -IKPI )
{    j21array[1]+=IK2PI;
}
j21valid[1] = true;
for(int ij21 = 0; ij21 < 2; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 2; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[3];
IkReal x867=IKcos(j21);
IkReal x868=IKsin(j21);
IkReal x869=(npy*x868);
IkReal x870=((1.0)*npx*x867);
evalcond[0]=(x869+(((-1.0)*x870)));
evalcond[1]=((((-1.0)*npx*x868))+(((-1.0)*npy*x867)));
evalcond[2]=(((sj20*x869))+(((-1.0)*sj20*x870)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j21array[2], cj21array[2], sj21array[2];
bool j21valid[2]={false};
_nj21 = 2;
CheckValue<IkReal> x872 = IKatan2WithCheck(IkReal(((-1.0)*npx*sj20)),IkReal((npy*sj20)),IKFAST_ATAN2_MAGTHRESH);
if(!x872.valid){
continue;
}
IkReal x871=x872.value;
j21array[0]=((-1.0)*x871);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
j21array[1]=((3.14159265358979)+(((-1.0)*x871)));
sj21array[1]=IKsin(j21array[1]);
cj21array[1]=IKcos(j21array[1]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
if( j21array[1] > IKPI )
{
    j21array[1]-=IK2PI;
}
else if( j21array[1] < -IKPI )
{    j21array[1]+=IK2PI;
}
j21valid[1] = true;
for(int ij21 = 0; ij21 < 2; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 2; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[3];
IkReal x873=IKcos(j21);
IkReal x874=IKsin(j21);
IkReal x875=((1.0)*x873);
IkReal x876=(npy*x874);
evalcond[0]=((((-1.0)*npx*x875))+x876);
evalcond[1]=((((-1.0)*npx*x874))+(((-1.0)*npy*x875)));
evalcond[2]=(((cj20*x876))+(((-1.0)*cj20*npx*x875)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j21array[2], cj21array[2], sj21array[2];
bool j21valid[2]={false};
_nj21 = 2;
CheckValue<IkReal> x878 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x878.valid){
continue;
}
IkReal x877=x878.value;
j21array[0]=((-1.0)*x877);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
j21array[1]=((3.14159265358979)+(((-1.0)*x877)));
sj21array[1]=IKsin(j21array[1]);
cj21array[1]=IKcos(j21array[1]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
if( j21array[1] > IKPI )
{
    j21array[1]-=IK2PI;
}
else if( j21array[1] < -IKPI )
{    j21array[1]+=IK2PI;
}
j21valid[1] = true;
for(int ij21 = 0; ij21 < 2; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 2; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[3];
IkReal x879=IKsin(j21);
IkReal x880=IKcos(j21);
IkReal x881=((1.0)*x880);
IkReal x882=(npy*x879);
evalcond[0]=((((-1.0)*npy*x881))+(((-1.0)*npx*x879)));
evalcond[1]=((((-1.0)*npx*sj20*x881))+((sj20*x882)));
evalcond[2]=(((cj20*x882))+(((-1.0)*cj20*npx*x881)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j21]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x883=((0.25)*npx);
IkReal x884=(npz*sj20);
IkReal x885=(cj19*cj20);
IkReal x886=((0.25)*npy);
CheckValue<IkReal> x887=IKPowWithIntegerCheck(IKsign((((cj20*(npx*npx)))+((cj20*(npy*npy))))),-1);
if(!x887.valid){
continue;
}
CheckValue<IkReal> x888 = IKatan2WithCheck(IkReal((((x883*x885))+(((-1.0)*npy*x884))+(((-1.0)*sj19*x886))+((cj20*x883)))),IkReal((((npx*x884))+((sj19*x883))+((x885*x886))+((cj20*x886)))),IKFAST_ATAN2_MAGTHRESH);
if(!x888.valid){
continue;
}
j21array[0]=((-1.5707963267949)+(((1.5707963267949)*(x887.value)))+(x888.value));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x889=IKcos(j21);
IkReal x890=IKsin(j21);
IkReal x891=((0.25)*sj19);
IkReal x892=(npy*x890);
IkReal x893=((1.0)*npx*x889);
evalcond[0]=((((-1.0)*x893))+x892+((cj20*x891)));
evalcond[1]=((0.25)+(((0.25)*cj19))+(((-1.0)*npy*x889))+(((-1.0)*npx*x890)));
evalcond[2]=((((-1.0)*cj20*npz))+((sj20*x892))+(((-1.0)*sj20*x893)));
evalcond[3]=(((npz*sj20))+(((-1.0)*cj20*x893))+x891+((cj20*x892)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x894=(cj20*npz);
IkReal x895=((0.25)*sj20);
CheckValue<IkReal> x896 = IKatan2WithCheck(IkReal((((npy*x894))+((cj19*npx*x895))+((npx*x895)))),IkReal((((npy*x895))+((cj19*npy*x895))+(((-1.0)*npx*x894)))),IKFAST_ATAN2_MAGTHRESH);
if(!x896.valid){
continue;
}
CheckValue<IkReal> x897=IKPowWithIntegerCheck(IKsign((((sj20*(npx*npx)))+((sj20*(npy*npy))))),-1);
if(!x897.valid){
continue;
}
j21array[0]=((-1.5707963267949)+(x896.value)+(((1.5707963267949)*(x897.value))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x898=IKcos(j21);
IkReal x899=IKsin(j21);
IkReal x900=((0.25)*sj19);
IkReal x901=(npy*x899);
IkReal x902=((1.0)*npx*x898);
evalcond[0]=((((-1.0)*x902))+((cj20*x900))+x901);
evalcond[1]=((0.25)+(((0.25)*cj19))+(((-1.0)*npy*x898))+(((-1.0)*npx*x899)));
evalcond[2]=((((-1.0)*cj20*npz))+(((-1.0)*sj20*x902))+((sj20*x901)));
evalcond[3]=(((cj20*x901))+((npz*sj20))+x900+(((-1.0)*cj20*x902)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x903=(cj20*sj19);
CheckValue<IkReal> x904=IKPowWithIntegerCheck(IKsign(((((4.0)*(npy*npy)))+(((4.0)*(npx*npx))))),-1);
if(!x904.valid){
continue;
}
CheckValue<IkReal> x905 = IKatan2WithCheck(IkReal((npx+((cj19*npx))+(((-1.0)*npy*x903)))),IkReal((((npx*x903))+npy+((cj19*npy)))),IKFAST_ATAN2_MAGTHRESH);
if(!x905.valid){
continue;
}
j21array[0]=((-1.5707963267949)+(((1.5707963267949)*(x904.value)))+(x905.value));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x906=IKcos(j21);
IkReal x907=IKsin(j21);
IkReal x908=((0.25)*sj19);
IkReal x909=(npy*x907);
IkReal x910=((1.0)*npx*x906);
evalcond[0]=(((cj20*x908))+(((-1.0)*x910))+x909);
evalcond[1]=((0.25)+(((-1.0)*npx*x907))+(((0.25)*cj19))+(((-1.0)*npy*x906)));
evalcond[2]=((((-1.0)*cj20*npz))+(((-1.0)*sj20*x910))+((sj20*x909)));
evalcond[3]=((((-1.0)*cj20*x910))+((cj20*x909))+((npz*sj20))+x908);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j21array[2], cj21array[2], sj21array[2];
bool j21valid[2]={false};
_nj21 = 2;
CheckValue<IkReal> x913 = IKatan2WithCheck(IkReal(((-1.0)*npy)),IkReal(((-1.0)*npx)),IKFAST_ATAN2_MAGTHRESH);
if(!x913.valid){
continue;
}
IkReal x911=((1.0)*(x913.value));
if((((npx*npx)+(npy*npy))) < -0.00001)
continue;
CheckValue<IkReal> x914=IKPowWithIntegerCheck(IKabs(IKsqrt(((npx*npx)+(npy*npy)))),-1);
if(!x914.valid){
continue;
}
if( (((x914.value)*(((0.25)+(((0.25)*cj19)))))) < -1-IKFAST_SINCOS_THRESH || (((x914.value)*(((0.25)+(((0.25)*cj19)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x912=IKasin(((x914.value)*(((0.25)+(((0.25)*cj19))))));
j21array[0]=((((-1.0)*x911))+(((-1.0)*x912)));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
j21array[1]=((3.14159265358979)+(((-1.0)*x911))+x912);
sj21array[1]=IKsin(j21array[1]);
cj21array[1]=IKcos(j21array[1]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
if( j21array[1] > IKPI )
{
    j21array[1]-=IK2PI;
}
else if( j21array[1] < -IKPI )
{    j21array[1]+=IK2PI;
}
j21valid[1] = true;
for(int ij21 = 0; ij21 < 2; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 2; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];

{
IkReal j20eval[3];
j20eval[0]=sj19;
j20eval[1]=((((0.25)*(IKabs(((((4.0)*cj21*npx))+(((-4.0)*npy*sj21)))))))+(IKabs(npz)));
j20eval[2]=IKsign(sj19);
if( IKabs(j20eval[0]) < 0.0000010000000000  || IKabs(j20eval[1]) < 0.0000010000000000  || IKabs(j20eval[2]) < 0.0000010000000000  )
{
{
IkReal j20eval[2];
j20eval[0]=sj19;
j20eval[1]=(((npy*sj19*sj21))+(((-1.0)*cj21*npx*sj19)));
if( IKabs(j20eval[0]) < 0.0000010000000000  || IKabs(j20eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j20]

} else
{
{
IkReal j20array[1], cj20array[1], sj20array[1];
bool j20valid[1]={false};
_nj20 = 1;
IkReal x915=((4.0)*sj19);
CheckValue<IkReal> x916=IKPowWithIntegerCheck(sj19,-1);
if(!x916.valid){
continue;
}
CheckValue<IkReal> x917=IKPowWithIntegerCheck(((((-1.0)*cj21*npx*x915))+((npy*sj21*x915))),-1);
if(!x917.valid){
continue;
}
if( IKabs(((-4.0)*npz*(x916.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x917.value)*(((-1.0)+(((16.0)*(npz*npz)))+(cj19*cj19))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-4.0)*npz*(x916.value)))+IKsqr(((x917.value)*(((-1.0)+(((16.0)*(npz*npz)))+(cj19*cj19)))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j20array[0]=IKatan2(((-4.0)*npz*(x916.value)), ((x917.value)*(((-1.0)+(((16.0)*(npz*npz)))+(cj19*cj19)))));
sj20array[0]=IKsin(j20array[0]);
cj20array[0]=IKcos(j20array[0]);
if( j20array[0] > IKPI )
{
    j20array[0]-=IK2PI;
}
else if( j20array[0] < -IKPI )
{    j20array[0]+=IK2PI;
}
j20valid[0] = true;
for(int ij20 = 0; ij20 < 1; ++ij20)
{
if( !j20valid[ij20] )
{
    continue;
}
_ij20[0] = ij20; _ij20[1] = -1;
for(int iij20 = ij20+1; iij20 < 1; ++iij20)
{
if( j20valid[iij20] && IKabs(cj20array[ij20]-cj20array[iij20]) < IKFAST_SOLUTION_THRESH && IKabs(sj20array[ij20]-sj20array[iij20]) < IKFAST_SOLUTION_THRESH )
{
    j20valid[iij20]=false; _ij20[1] = iij20; break; 
}
}
j20 = j20array[ij20]; cj20 = cj20array[ij20]; sj20 = sj20array[ij20];
{
IkReal evalcond[4];
IkReal x918=IKsin(j20);
IkReal x919=IKcos(j20);
IkReal x920=((1.0)*npz);
IkReal x921=(npy*sj21);
IkReal x922=((0.25)*sj19);
IkReal x923=((1.0)*cj21*npx);
evalcond[0]=((((-1.0)*x920))+(((-1.0)*x918*x922)));
evalcond[1]=((((-1.0)*x923))+((x919*x922))+x921);
evalcond[2]=(((x918*x921))+(((-1.0)*x918*x923))+(((-1.0)*x919*x920)));
evalcond[3]=(((x919*x921))+(((-1.0)*x919*x923))+((npz*x918))+x922);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j20array[1], cj20array[1], sj20array[1];
bool j20valid[1]={false};
_nj20 = 1;
CheckValue<IkReal> x924 = IKatan2WithCheck(IkReal(((-4.0)*npz)),IkReal(((((4.0)*cj21*npx))+(((-4.0)*npy*sj21)))),IKFAST_ATAN2_MAGTHRESH);
if(!x924.valid){
continue;
}
CheckValue<IkReal> x925=IKPowWithIntegerCheck(IKsign(sj19),-1);
if(!x925.valid){
continue;
}
j20array[0]=((-1.5707963267949)+(x924.value)+(((1.5707963267949)*(x925.value))));
sj20array[0]=IKsin(j20array[0]);
cj20array[0]=IKcos(j20array[0]);
if( j20array[0] > IKPI )
{
    j20array[0]-=IK2PI;
}
else if( j20array[0] < -IKPI )
{    j20array[0]+=IK2PI;
}
j20valid[0] = true;
for(int ij20 = 0; ij20 < 1; ++ij20)
{
if( !j20valid[ij20] )
{
    continue;
}
_ij20[0] = ij20; _ij20[1] = -1;
for(int iij20 = ij20+1; iij20 < 1; ++iij20)
{
if( j20valid[iij20] && IKabs(cj20array[ij20]-cj20array[iij20]) < IKFAST_SOLUTION_THRESH && IKabs(sj20array[ij20]-sj20array[iij20]) < IKFAST_SOLUTION_THRESH )
{
    j20valid[iij20]=false; _ij20[1] = iij20; break; 
}
}
j20 = j20array[ij20]; cj20 = cj20array[ij20]; sj20 = sj20array[ij20];
{
IkReal evalcond[4];
IkReal x926=IKsin(j20);
IkReal x927=IKcos(j20);
IkReal x928=((1.0)*npz);
IkReal x929=(npy*sj21);
IkReal x930=((0.25)*sj19);
IkReal x931=((1.0)*cj21*npx);
evalcond[0]=((((-1.0)*x928))+(((-1.0)*x926*x930)));
evalcond[1]=(((x927*x930))+x929+(((-1.0)*x931)));
evalcond[2]=((((-1.0)*x927*x928))+(((-1.0)*x926*x931))+((x926*x929)));
evalcond[3]=(((npz*x926))+((x927*x929))+(((-1.0)*x927*x931))+x930);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
}
}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x59=((1.0)*sj19);
IkReal x60=((1.0)*sj21);
IkReal x61=((1.0)*sj20);
IkReal x62=((1.0)*cj19);
IkReal x63=((((-1.0)*r01*x60))+((cj21*r00)));
IkReal x64=(((r00*sj21))+((cj21*r01)));
IkReal x65=((((-1.0)*r11*x60))+((cj21*r10)));
IkReal x66=(((r10*sj21))+((cj21*r11)));
IkReal x67=((((-1.0)*r21*x60))+((cj21*r20)));
IkReal x68=(((r20*sj21))+((cj21*r21)));
IkReal x69=((((-1.0)*r02*x61))+((cj20*x63)));
IkReal x70=((((-1.0)*r12*x61))+((cj20*x65)));
IkReal x71=((((-1.0)*r22*x61))+((cj20*x67)));
new_r00=((((-1.0)*x59*x64))+((cj19*x69)));
new_r01=(((cj20*r02))+((sj20*x63)));
new_r02=((((-1.0)*x59*x69))+(((-1.0)*x62*x64)));
new_r10=((((-1.0)*x59*x66))+((cj19*x70)));
new_r11=(((cj20*r12))+((sj20*x65)));
new_r12=((((-1.0)*x59*x70))+(((-1.0)*x62*x66)));
new_r20=((((-1.0)*x59*x68))+((cj19*x71)));
new_r21=(((cj20*r22))+((sj20*x67)));
new_r22=((((-1.0)*x59*x71))+(((-1.0)*x62*x68)));
{
IkReal j17array[2], cj17array[2], sj17array[2];
bool j17valid[2]={false};
_nj17 = 2;
sj17array[0]=((-1.0)*new_r22);
if( sj17array[0] >= -1-IKFAST_SINCOS_THRESH && sj17array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j17valid[0] = j17valid[1] = true;
    j17array[0] = IKasin(sj17array[0]);
    cj17array[0] = IKcos(j17array[0]);
    sj17array[1] = sj17array[0];
    j17array[1] = j17array[0] > 0 ? (IKPI-j17array[0]) : (-IKPI-j17array[0]);
    cj17array[1] = -cj17array[0];
}
else if( isnan(sj17array[0]) )
{
    // probably any value will work
    j17valid[0] = true;
    cj17array[0] = 1; sj17array[0] = 0; j17array[0] = 0;
}
for(int ij17 = 0; ij17 < 2; ++ij17)
{
if( !j17valid[ij17] )
{
    continue;
}
_ij17[0] = ij17; _ij17[1] = -1;
for(int iij17 = ij17+1; iij17 < 2; ++iij17)
{
if( j17valid[iij17] && IKabs(cj17array[ij17]-cj17array[iij17]) < IKFAST_SOLUTION_THRESH && IKabs(sj17array[ij17]-sj17array[iij17]) < IKFAST_SOLUTION_THRESH )
{
    j17valid[iij17]=false; _ij17[1] = iij17; break; 
}
}
j17 = j17array[ij17]; cj17 = cj17array[ij17]; sj17 = sj17array[ij17];

{
IkReal j18eval[3];
j18eval[0]=cj17;
j18eval[1]=IKsign(cj17);
j18eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j18eval[0]) < 0.0000010000000000  || IKabs(j18eval[1]) < 0.0000010000000000  || IKabs(j18eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
j16eval[0]=cj17;
j16eval[1]=IKsign(cj17);
j16eval[2]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[2];
j16eval[0]=cj17;
j16eval[1]=new_r02;
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j18mul = 1;
j18=0;
j16mul=1.0;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16=IKatan2(new_r01, ((-1.0)*new_r11));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].fmul = j16mul;
vinfos[0].freeind = 0;
vinfos[0].maxsolutions = 0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].fmul = j18mul;
vinfos[2].freeind = 0;
vinfos[2].maxsolutions = 0;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(1);
vfree[0] = 2;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j18mul = 1;
j18=0;
j16mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16=IKatan2(((-1.0)*new_r01), new_r11);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].fmul = j16mul;
vinfos[0].freeind = 0;
vinfos[0].maxsolutions = 0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].fmul = j18mul;
vinfos[2].freeind = 0;
vinfos[2].maxsolutions = 0;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(1);
vfree[0] = 2;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
IkReal x72=new_r22*new_r22;
IkReal x73=((16.0)*new_r01);
IkReal x74=(new_r00*new_r22);
IkReal x75=(x72*x73);
j16eval[0]=((IKabs(((((-32.0)*new_r11*x72))+(((16.0)*x74))+(((16.0)*new_r11)))))+(IKabs(((((8.0)*x74))+(((-8.0)*new_r11)))))+(IKabs(((((-1.0)*x73))+x75)))+(IKabs(((((-1.0)*x75))+x73))));
if( IKabs(j16eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j16, j18]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j16evalpoly[1];
IkReal x76=new_r22*new_r22;
IkReal x77=((16.0)*new_r01);
IkReal x78=(new_r00*new_r22);
IkReal x79=(x76*x77);
IkReal x80=((((8.0)*x78))+(((-8.0)*new_r11)));
op[0]=x80;
op[1]=((((-1.0)*x77))+x79);
op[2]=((((-32.0)*new_r11*x76))+(((16.0)*x78))+(((16.0)*new_r11)));
op[3]=((((-1.0)*x79))+x77);
op[4]=x80;
polyroots4(op,zeror,numroots);
IkReal j16array[4], cj16array[4], sj16array[4], tempj16array[1];
int numsolutions = 0;
for(int ij16 = 0; ij16 < numroots; ++ij16)
{
IkReal htj16 = zeror[ij16];
tempj16array[0]=((2.0)*(atan(htj16)));
for(int kj16 = 0; kj16 < 1; ++kj16)
{
j16array[numsolutions] = tempj16array[kj16];
if( j16array[numsolutions] > IKPI )
{
    j16array[numsolutions]-=IK2PI;
}
else if( j16array[numsolutions] < -IKPI )
{
    j16array[numsolutions]+=IK2PI;
}
sj16array[numsolutions] = IKsin(j16array[numsolutions]);
cj16array[numsolutions] = IKcos(j16array[numsolutions]);
numsolutions++;
}
}
bool j16valid[4]={true,true,true,true};
_nj16 = 4;
for(int ij16 = 0; ij16 < numsolutions; ++ij16)
    {
if( !j16valid[ij16] )
{
    continue;
}
    j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
htj16 = IKtan(j16/2);

IkReal x81=new_r22*new_r22;
IkReal x82=((16.0)*new_r10);
IkReal x83=(new_r11*new_r22);
IkReal x84=((8.0)*x83);
IkReal x85=(new_r00*x81);
IkReal x86=(x81*x82);
IkReal x87=((8.0)*x85);
j16evalpoly[0]=((((htj16*htj16*htj16)*((x82+(((-1.0)*x86))))))+(((htj16*htj16)*(((((32.0)*new_r00))+(((-16.0)*x83))+(((-16.0)*x85))))))+(((htj16*htj16*htj16*htj16)*((x87+(((-1.0)*x84))))))+((htj16*((x86+(((-1.0)*x82))))))+x87+(((-1.0)*x84)));
if( IKabs(j16evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < numsolutions; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
{
IkReal j18eval[3];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
IkReal x88=new_r22*new_r22;
IkReal x89=cj16*cj16;
IkReal x90=(new_r22*sj16);
IkReal x91=((((-1.0)*x88))+(((-1.0)*x89))+((x88*x89)));
j18eval[0]=x91;
j18eval[1]=((IKabs((((new_r00*x90))+((cj16*new_r01)))))+(IKabs((((new_r01*x90))+(((-1.0)*cj16*new_r00))))));
j18eval[2]=IKsign(x91);
if( IKabs(j18eval[0]) < 0.0000010000000000  || IKabs(j18eval[1]) < 0.0000010000000000  || IKabs(j18eval[2]) < 0.0000010000000000  )
{
{
IkReal j18eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j18eval[0]=new_r22;
if( IKabs(j18eval[0]) < 0.0000010000000000  )
{
{
IkReal j18eval[2];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j18eval[0]=cj16;
j18eval[1]=new_r22;
if( IKabs(j18eval[0]) < 0.0000010000000000  || IKabs(j18eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j16)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[6];
IkReal x92=IKsin(j18);
IkReal x93=IKcos(j18);
IkReal x94=((1.0)*new_r22);
IkReal x95=((1.0)*x93);
evalcond[0]=(x92+new_r11);
evalcond[1]=((((-1.0)*x95))+new_r10);
evalcond[2]=((((-1.0)*x92*x94))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x93*x94)));
evalcond[4]=((((-1.0)*new_r00*x94))+(((-1.0)*x92)));
evalcond[5]=((((-1.0)*new_r01*x94))+(((-1.0)*x95)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j16)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[6];
IkReal x96=IKsin(j18);
IkReal x97=IKcos(j18);
IkReal x98=((1.0)*new_r22);
IkReal x99=((1.0)*x97);
evalcond[0]=(x96+(((-1.0)*new_r11)));
evalcond[1]=(new_r00+(((-1.0)*x96*x98)));
evalcond[2]=(new_r01+(((-1.0)*x97*x98)));
evalcond[3]=((((-1.0)*new_r10))+(((-1.0)*x99)));
evalcond[4]=(((new_r00*new_r22))+(((-1.0)*x96)));
evalcond[5]=(((new_r01*new_r22))+(((-1.0)*x99)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x100=new_r22*new_r22;
CheckValue<IkReal> x101=IKPowWithIntegerCheck(((-1.0)+x100),-1);
if(!x101.valid){
continue;
}
if(((x100*(x101.value))) < -0.00001)
continue;
IkReal gconst6=IKsqrt((x100*(x101.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.0)+(IKsign(sj16)))))+(IKabs(((((-1.0)*gconst6))+cj16)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if((((1.0)+(((-1.0)*(gconst6*gconst6))))) < -0.00001)
continue;
IkReal x102=IKsqrt(((1.0)+(((-1.0)*(gconst6*gconst6)))));
if( IKabs(((((-1.0)*gconst6*new_r01))+(((-1.0)*new_r11*x102)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r10*x102))+((gconst6*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*gconst6*new_r01))+(((-1.0)*new_r11*x102))))+IKsqr((((new_r10*x102))+((gconst6*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-1.0)*gconst6*new_r01))+(((-1.0)*new_r11*x102))), (((new_r10*x102))+((gconst6*new_r00))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[10];
IkReal x103=IKsin(j18);
IkReal x104=IKcos(j18);
IkReal x105=(gconst6*new_r10);
IkReal x106=(gconst6*new_r11);
IkReal x107=((1.0)*x104);
IkReal x108=((1.0)*gconst6*new_r22);
IkReal x109=((1.0)*x103);
IkReal x110=x102;
IkReal x111=((1.0)*x110);
IkReal x112=(x103*x110);
IkReal x113=(new_r22*x111);
evalcond[0]=(((new_r11*x110))+((gconst6*new_r01))+x103);
evalcond[1]=(((new_r10*x110))+((gconst6*new_r00))+(((-1.0)*x107)));
evalcond[2]=(((gconst6*x103))+new_r01+((new_r22*x104*x110)));
evalcond[3]=(x112+(((-1.0)*gconst6*new_r22*x107))+new_r11);
evalcond[4]=((((-1.0)*new_r00*x111))+x105+(((-1.0)*new_r22*x109)));
evalcond[5]=((((-1.0)*new_r01*x111))+x106+(((-1.0)*new_r22*x107)));
evalcond[6]=(((new_r22*x112))+(((-1.0)*gconst6*x107))+new_r00);
evalcond[7]=((((-1.0)*x107*x110))+(((-1.0)*x103*x108))+new_r10);
evalcond[8]=((((-1.0)*new_r00*x113))+((new_r22*x105))+(((-1.0)*x109)));
evalcond[9]=((((-1.0)*new_r01*x113))+((new_r22*x106))+(((-1.0)*x107)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x114=new_r22*new_r22;
CheckValue<IkReal> x115=IKPowWithIntegerCheck(((-1.0)+x114),-1);
if(!x115.valid){
continue;
}
if(((x114*(x115.value))) < -0.00001)
continue;
IkReal gconst6=IKsqrt((x114*(x115.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.0)+(IKsign(sj16)))))+(IKabs(((((-1.0)*gconst6))+cj16)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if((((1.0)+(((-1.0)*(gconst6*gconst6))))) < -0.00001)
continue;
IkReal x116=IKsqrt(((1.0)+(((-1.0)*(gconst6*gconst6)))));
if( IKabs((((new_r11*x116))+(((-1.0)*gconst6*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((gconst6*new_r00))+(((-1.0)*new_r10*x116)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r11*x116))+(((-1.0)*gconst6*new_r01))))+IKsqr((((gconst6*new_r00))+(((-1.0)*new_r10*x116))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2((((new_r11*x116))+(((-1.0)*gconst6*new_r01))), (((gconst6*new_r00))+(((-1.0)*new_r10*x116))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[10];
IkReal x117=IKsin(j18);
IkReal x118=IKcos(j18);
IkReal x119=(gconst6*new_r11);
IkReal x120=(gconst6*new_r10);
IkReal x121=((1.0)*x118);
IkReal x122=((1.0)*gconst6*new_r22);
IkReal x123=((1.0)*x117);
IkReal x124=x116;
IkReal x125=(new_r01*x124);
IkReal x126=(new_r00*x124);
IkReal x127=((1.0)*x124);
IkReal x128=(x123*x124);
evalcond[0]=(((gconst6*new_r01))+x117+(((-1.0)*new_r11*x127)));
evalcond[1]=((((-1.0)*new_r10*x127))+((gconst6*new_r00))+(((-1.0)*x121)));
evalcond[2]=(x126+x120+(((-1.0)*new_r22*x123)));
evalcond[3]=(x125+x119+(((-1.0)*new_r22*x121)));
evalcond[4]=(((gconst6*x117))+(((-1.0)*new_r22*x121*x124))+new_r01);
evalcond[5]=((((-1.0)*x117*x122))+new_r10+((x118*x124)));
evalcond[6]=(((new_r22*x126))+((new_r22*x120))+(((-1.0)*x123)));
evalcond[7]=(((new_r22*x119))+((new_r22*x125))+(((-1.0)*x121)));
evalcond[8]=((((-1.0)*x128))+new_r11+(((-1.0)*gconst6*new_r22*x121)));
evalcond[9]=((((-1.0)*gconst6*x121))+(((-1.0)*new_r22*x128))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x129=new_r22*new_r22;
CheckValue<IkReal> x130=IKPowWithIntegerCheck(((-1.0)+x129),-1);
if(!x130.valid){
continue;
}
if(((x129*(x130.value))) < -0.00001)
continue;
IkReal gconst7=((-1.0)*(IKsqrt((x129*(x130.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.0)+(IKsign(sj16)))))+(IKabs(((((-1.0)*gconst7))+cj16)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if((((1.0)+(((-1.0)*(gconst7*gconst7))))) < -0.00001)
continue;
IkReal x131=IKsqrt(((1.0)+(((-1.0)*(gconst7*gconst7)))));
if( IKabs(((((-1.0)*gconst7*new_r01))+(((-1.0)*new_r11*x131)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r10*x131))+((gconst7*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*gconst7*new_r01))+(((-1.0)*new_r11*x131))))+IKsqr((((new_r10*x131))+((gconst7*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-1.0)*gconst7*new_r01))+(((-1.0)*new_r11*x131))), (((new_r10*x131))+((gconst7*new_r00))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[10];
IkReal x132=IKsin(j18);
IkReal x133=IKcos(j18);
IkReal x134=((1.0)*new_r00);
IkReal x135=((1.0)*new_r01);
IkReal x136=(gconst7*new_r22);
IkReal x137=((1.0)*x133);
IkReal x138=((1.0)*x132);
IkReal x139=x131;
IkReal x140=(new_r22*x139);
evalcond[0]=(x132+((gconst7*new_r01))+((new_r11*x139)));
evalcond[1]=((((-1.0)*x137))+((new_r10*x139))+((gconst7*new_r00)));
evalcond[2]=(((gconst7*x132))+new_r01+((x133*x140)));
evalcond[3]=((((-1.0)*x136*x137))+((x132*x139))+new_r11);
evalcond[4]=((((-1.0)*x134*x139))+(((-1.0)*new_r22*x138))+((gconst7*new_r10)));
evalcond[5]=((((-1.0)*x135*x139))+(((-1.0)*new_r22*x137))+((gconst7*new_r11)));
evalcond[6]=((((-1.0)*gconst7*x137))+new_r00+((x132*x140)));
evalcond[7]=((((-1.0)*x137*x139))+(((-1.0)*x136*x138))+new_r10);
evalcond[8]=((((-1.0)*x134*x140))+(((-1.0)*x138))+((new_r10*x136)));
evalcond[9]=((((-1.0)*x137))+((new_r11*x136))+(((-1.0)*x135*x140)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x141=new_r22*new_r22;
CheckValue<IkReal> x142=IKPowWithIntegerCheck(((-1.0)+x141),-1);
if(!x142.valid){
continue;
}
if(((x141*(x142.value))) < -0.00001)
continue;
IkReal gconst7=((-1.0)*(IKsqrt((x141*(x142.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst7))+cj16)))+(IKabs(((1.0)+(IKsign(sj16)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if((((1.0)+(((-1.0)*(gconst7*gconst7))))) < -0.00001)
continue;
IkReal x143=IKsqrt(((1.0)+(((-1.0)*(gconst7*gconst7)))));
if( IKabs(((((-1.0)*gconst7*new_r01))+((new_r11*x143)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r10*x143))+((gconst7*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*gconst7*new_r01))+((new_r11*x143))))+IKsqr(((((-1.0)*new_r10*x143))+((gconst7*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-1.0)*gconst7*new_r01))+((new_r11*x143))), ((((-1.0)*new_r10*x143))+((gconst7*new_r00))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[10];
IkReal x144=IKsin(j18);
IkReal x145=IKcos(j18);
IkReal x146=(gconst7*new_r11);
IkReal x147=(gconst7*new_r22);
IkReal x148=((1.0)*x145);
IkReal x149=((1.0)*x144);
IkReal x150=x143;
IkReal x151=(new_r22*x150);
IkReal x152=((1.0)*x150);
evalcond[0]=(x144+(((-1.0)*new_r11*x152))+((gconst7*new_r01)));
evalcond[1]=((((-1.0)*x148))+(((-1.0)*new_r10*x152))+((gconst7*new_r00)));
evalcond[2]=(((new_r00*x150))+(((-1.0)*new_r22*x149))+((gconst7*new_r10)));
evalcond[3]=(((new_r01*x150))+(((-1.0)*new_r22*x148))+x146);
evalcond[4]=((((-1.0)*x148*x151))+new_r01+((gconst7*x144)));
evalcond[5]=(((x145*x150))+(((-1.0)*x147*x149))+new_r10);
evalcond[6]=((((-1.0)*x149))+((new_r00*x151))+((new_r10*x147)));
evalcond[7]=((((-1.0)*x148))+((new_r01*x151))+((new_r22*x146)));
evalcond[8]=((((-1.0)*x147*x148))+new_r11+(((-1.0)*x149*x150)));
evalcond[9]=((((-1.0)*gconst7*x148))+new_r00+(((-1.0)*x149*x151)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j18]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x153=((1.0)*cj16*new_r01);
CheckValue<IkReal> x154=IKPowWithIntegerCheck(cj16,-1);
if(!x154.valid){
continue;
}
CheckValue<IkReal> x155=IKPowWithIntegerCheck(new_r22,-1);
if(!x155.valid){
continue;
}
if( IKabs(((((-1.0)*x153))+(((-1.0)*new_r11*sj16)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x154.value)*(x155.value)*((((new_r11*(cj16*cj16)))+(((-1.0)*sj16*x153)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x153))+(((-1.0)*new_r11*sj16))))+IKsqr(((x154.value)*(x155.value)*((((new_r11*(cj16*cj16)))+(((-1.0)*sj16*x153))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-1.0)*x153))+(((-1.0)*new_r11*sj16))), ((x154.value)*(x155.value)*((((new_r11*(cj16*cj16)))+(((-1.0)*sj16*x153))))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[10];
IkReal x156=IKsin(j18);
IkReal x157=IKcos(j18);
IkReal x158=((1.0)*sj16);
IkReal x159=(cj16*new_r10);
IkReal x160=(cj16*new_r11);
IkReal x161=((1.0)*x157);
IkReal x162=(new_r22*x157);
IkReal x163=(sj16*x156);
IkReal x164=(cj16*x156);
IkReal x165=((1.0)*x156);
evalcond[0]=(x156+((cj16*new_r01))+((new_r11*sj16)));
evalcond[1]=((((-1.0)*x161))+((cj16*new_r00))+((new_r10*sj16)));
evalcond[2]=(x164+new_r01+((sj16*x162)));
evalcond[3]=(x163+(((-1.0)*cj16*new_r22*x161))+new_r11);
evalcond[4]=(x159+(((-1.0)*new_r22*x165))+(((-1.0)*new_r00*x158)));
evalcond[5]=(x160+(((-1.0)*new_r22*x161))+(((-1.0)*new_r01*x158)));
evalcond[6]=((((-1.0)*cj16*x161))+((new_r22*x163))+new_r00);
evalcond[7]=((((-1.0)*x157*x158))+(((-1.0)*new_r22*x164))+new_r10);
evalcond[8]=((((-1.0)*x165))+((new_r22*x159))+(((-1.0)*new_r00*new_r22*x158)));
evalcond[9]=((((-1.0)*x161))+(((-1.0)*new_r01*new_r22*x158))+((new_r22*x160)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x166=((1.0)*new_r01);
CheckValue<IkReal> x167=IKPowWithIntegerCheck(new_r22,-1);
if(!x167.valid){
continue;
}
if( IKabs(((((-1.0)*cj16*x166))+(((-1.0)*new_r11*sj16)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x167.value)*(((((-1.0)*sj16*x166))+((cj16*new_r11)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj16*x166))+(((-1.0)*new_r11*sj16))))+IKsqr(((x167.value)*(((((-1.0)*sj16*x166))+((cj16*new_r11))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-1.0)*cj16*x166))+(((-1.0)*new_r11*sj16))), ((x167.value)*(((((-1.0)*sj16*x166))+((cj16*new_r11))))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[10];
IkReal x168=IKsin(j18);
IkReal x169=IKcos(j18);
IkReal x170=((1.0)*sj16);
IkReal x171=(cj16*new_r10);
IkReal x172=(cj16*new_r11);
IkReal x173=((1.0)*x169);
IkReal x174=(new_r22*x169);
IkReal x175=(sj16*x168);
IkReal x176=(cj16*x168);
IkReal x177=((1.0)*x168);
evalcond[0]=(x168+((cj16*new_r01))+((new_r11*sj16)));
evalcond[1]=((((-1.0)*x173))+((cj16*new_r00))+((new_r10*sj16)));
evalcond[2]=(x176+new_r01+((sj16*x174)));
evalcond[3]=(x175+(((-1.0)*cj16*new_r22*x173))+new_r11);
evalcond[4]=(x171+(((-1.0)*new_r22*x177))+(((-1.0)*new_r00*x170)));
evalcond[5]=(x172+(((-1.0)*new_r22*x173))+(((-1.0)*new_r01*x170)));
evalcond[6]=(((new_r22*x175))+new_r00+(((-1.0)*cj16*x173)));
evalcond[7]=((((-1.0)*new_r22*x176))+new_r10+(((-1.0)*x169*x170)));
evalcond[8]=((((-1.0)*x177))+((new_r22*x171))+(((-1.0)*new_r00*new_r22*x170)));
evalcond[9]=((((-1.0)*x173))+(((-1.0)*new_r01*new_r22*x170))+((new_r22*x172)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x178=new_r22*new_r22;
IkReal x179=cj16*cj16;
IkReal x180=(new_r22*sj16);
CheckValue<IkReal> x181 = IKatan2WithCheck(IkReal((((new_r00*x180))+((cj16*new_r01)))),IkReal((((new_r01*x180))+(((-1.0)*cj16*new_r00)))),IKFAST_ATAN2_MAGTHRESH);
if(!x181.valid){
continue;
}
CheckValue<IkReal> x182=IKPowWithIntegerCheck(IKsign((((x178*x179))+(((-1.0)*x179))+(((-1.0)*x178)))),-1);
if(!x182.valid){
continue;
}
j18array[0]=((-1.5707963267949)+(x181.value)+(((1.5707963267949)*(x182.value))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[10];
IkReal x183=IKsin(j18);
IkReal x184=IKcos(j18);
IkReal x185=((1.0)*sj16);
IkReal x186=(cj16*new_r10);
IkReal x187=(cj16*new_r11);
IkReal x188=((1.0)*x184);
IkReal x189=(new_r22*x184);
IkReal x190=(sj16*x183);
IkReal x191=(cj16*x183);
IkReal x192=((1.0)*x183);
evalcond[0]=(x183+((cj16*new_r01))+((new_r11*sj16)));
evalcond[1]=((((-1.0)*x188))+((cj16*new_r00))+((new_r10*sj16)));
evalcond[2]=(x191+((sj16*x189))+new_r01);
evalcond[3]=((((-1.0)*cj16*new_r22*x188))+x190+new_r11);
evalcond[4]=((((-1.0)*new_r22*x192))+x186+(((-1.0)*new_r00*x185)));
evalcond[5]=((((-1.0)*new_r22*x188))+x187+(((-1.0)*new_r01*x185)));
evalcond[6]=(((new_r22*x190))+new_r00+(((-1.0)*cj16*x188)));
evalcond[7]=((((-1.0)*new_r22*x191))+(((-1.0)*x184*x185))+new_r10);
evalcond[8]=((((-1.0)*x192))+((new_r22*x186))+(((-1.0)*new_r00*new_r22*x185)));
evalcond[9]=((((-1.0)*x188))+((new_r22*x187))+(((-1.0)*new_r01*new_r22*x185)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j16, j18]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x194=IKPowWithIntegerCheck(cj17,-1);
if(!x194.valid){
continue;
}
IkReal x193=x194.value;
CheckValue<IkReal> x195=IKPowWithIntegerCheck(new_r02,-1);
if(!x195.valid){
continue;
}
CheckValue<IkReal> x196=IKPowWithIntegerCheck(x193,-2);
if(!x196.valid){
continue;
}
if( IKabs((x193*(x195.value)*(((x196.value)+(((-1.0)*(new_r12*new_r12))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r12*x193)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x193*(x195.value)*(((x196.value)+(((-1.0)*(new_r12*new_r12)))))))+IKsqr(((-1.0)*new_r12*x193))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2((x193*(x195.value)*(((x196.value)+(((-1.0)*(new_r12*new_r12)))))), ((-1.0)*new_r12*x193));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x197=IKcos(j16);
IkReal x198=IKsin(j16);
IkReal x199=(new_r12*x197);
IkReal x200=(cj17*x197);
IkReal x201=((1.0)*x198);
evalcond[0]=(x200+new_r12);
evalcond[1]=((((-1.0)*cj17*x201))+new_r02);
evalcond[2]=(((new_r02*x197))+((new_r12*x198)));
evalcond[3]=((((-1.0)*new_r02*x201))+x199+cj17);
evalcond[4]=(((new_r10*x200))+(((-1.0)*cj17*new_r00*x201))+((new_r20*sj17)));
evalcond[5]=(((new_r11*x200))+(((-1.0)*cj17*new_r01*x201))+((new_r21*sj17)));
evalcond[6]=(((new_r02*sj17*x198))+((cj17*new_r22))+(((-1.0)*sj17*x199)));
evalcond[7]=((1.0)+((cj17*x199))+((new_r22*sj17))+(((-1.0)*cj17*new_r02*x201)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j18eval[3];
j18eval[0]=cj17;
j18eval[1]=IKsign(cj17);
j18eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j18eval[0]) < 0.0000010000000000  || IKabs(j18eval[1]) < 0.0000010000000000  || IKabs(j18eval[2]) < 0.0000010000000000  )
{
{
IkReal j18eval[2];
j18eval[0]=cj17;
j18eval[1]=sj16;
if( IKabs(j18eval[0]) < 0.0000010000000000  || IKabs(j18eval[1]) < 0.0000010000000000  )
{
{
IkReal j18eval[3];
j18eval[0]=cj17;
j18eval[1]=sj16;
j18eval[2]=sj17;
if( IKabs(j18eval[0]) < 0.0000010000000000  || IKabs(j18eval[1]) < 0.0000010000000000  || IKabs(j18eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x202=((1.0)*cj16);
if( IKabs(((((-1.0)*new_r11*sj16))+(((-1.0)*new_r01*x202)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj16))+(((-1.0)*new_r11*x202)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*sj16))+(((-1.0)*new_r01*x202))))+IKsqr((((new_r01*sj16))+(((-1.0)*new_r11*x202))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-1.0)*new_r11*sj16))+(((-1.0)*new_r01*x202))), (((new_r01*sj16))+(((-1.0)*new_r11*x202))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[8];
IkReal x203=IKsin(j18);
IkReal x204=IKcos(j18);
IkReal x205=((1.0)*sj16);
IkReal x206=(cj16*x203);
IkReal x207=(cj16*x204);
IkReal x208=(x204*x205);
evalcond[0]=(x203+((cj16*new_r01))+((new_r11*sj16)));
evalcond[1]=((((-1.0)*new_r00*x205))+x203+((cj16*new_r10)));
evalcond[2]=(x204+(((-1.0)*new_r01*x205))+((cj16*new_r11)));
evalcond[3]=(((cj16*new_r00))+((new_r10*sj16))+(((-1.0)*x204)));
evalcond[4]=(x207+((sj16*x203))+new_r11);
evalcond[5]=((((-1.0)*x208))+x206+new_r01);
evalcond[6]=((((-1.0)*x208))+x206+new_r10);
evalcond[7]=((((-1.0)*x203*x205))+new_r00+(((-1.0)*x207)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x209=((1.0)*new_r01);
if( IKabs(((((-1.0)*new_r11*sj16))+(((-1.0)*cj16*x209)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj16*x209))+((cj16*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*sj16))+(((-1.0)*cj16*x209))))+IKsqr(((((-1.0)*sj16*x209))+((cj16*new_r11))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-1.0)*new_r11*sj16))+(((-1.0)*cj16*x209))), ((((-1.0)*sj16*x209))+((cj16*new_r11))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[8];
IkReal x210=IKcos(j18);
IkReal x211=IKsin(j18);
IkReal x212=((1.0)*sj16);
IkReal x213=((1.0)*x210);
IkReal x214=(sj16*x211);
IkReal x215=(cj16*x211);
IkReal x216=(sj16*x210);
IkReal x217=(cj16*x213);
evalcond[0]=(x211+((cj16*new_r01))+((new_r11*sj16)));
evalcond[1]=((((-1.0)*x213))+((cj16*new_r00))+((new_r10*sj16)));
evalcond[2]=(x215+x216+new_r01);
evalcond[3]=(x214+new_r11+(((-1.0)*x217)));
evalcond[4]=((((-1.0)*x211))+(((-1.0)*new_r00*x212))+((cj16*new_r10)));
evalcond[5]=((((-1.0)*new_r01*x212))+(((-1.0)*x213))+((cj16*new_r11)));
evalcond[6]=(x214+new_r00+(((-1.0)*x217)));
evalcond[7]=((((-1.0)*x210*x212))+(((-1.0)*x215))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j16))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-1.0)*new_r01), new_r00);
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[8];
IkReal x218=IKcos(j18);
IkReal x219=IKsin(j18);
IkReal x220=((1.0)*sj17);
IkReal x221=((1.0)*x218);
IkReal x222=((1.0)*x219);
evalcond[0]=(x219+new_r01);
evalcond[1]=(new_r00+(((-1.0)*x221)));
evalcond[2]=(((sj17*x218))+new_r11);
evalcond[3]=(((sj17*x219))+new_r10);
evalcond[4]=((((-1.0)*cj17*x222))+new_r20);
evalcond[5]=((((-1.0)*cj17*x221))+new_r21);
evalcond[6]=((((-1.0)*new_r10*x220))+((cj17*new_r20))+(((-1.0)*x222)));
evalcond[7]=((((-1.0)*new_r11*x220))+((cj17*new_r21))+(((-1.0)*x221)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j16)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(new_r01, ((-1.0)*new_r00));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[8];
IkReal x223=IKsin(j18);
IkReal x224=IKcos(j18);
IkReal x225=((1.0)*x224);
IkReal x226=((1.0)*x223);
evalcond[0]=(x223+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*cj17*x226))+new_r20);
evalcond[2]=((((-1.0)*cj17*x225))+new_r21);
evalcond[3]=((((-1.0)*sj17*x225))+new_r11);
evalcond[4]=((((-1.0)*new_r00))+(((-1.0)*x225)));
evalcond[5]=((((-1.0)*new_r10))+((sj17*x223)));
evalcond[6]=(((cj17*new_r20))+((new_r10*sj17))+(((-1.0)*x226)));
evalcond[7]=(((cj17*new_r21))+((new_r11*sj17))+(((-1.0)*x225)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(new_r20, new_r21);
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[8];
IkReal x227=IKsin(j18);
IkReal x228=IKcos(j18);
IkReal x229=((1.0)*x228);
evalcond[0]=(new_r20+(((-1.0)*x227)));
evalcond[1]=(new_r21+(((-1.0)*x229)));
evalcond[2]=(new_r11+((sj16*x227)));
evalcond[3]=(((cj16*x227))+new_r01);
evalcond[4]=(new_r10+(((-1.0)*new_r02*x229)));
evalcond[5]=((((-1.0)*cj16*x229))+new_r00);
evalcond[6]=(x227+((cj16*new_r01))+((new_r11*sj16)));
evalcond[7]=(((cj16*new_r00))+((new_r10*sj16))+(((-1.0)*x229)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20))+IKsqr(((-1.0)*new_r21))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-1.0)*new_r20), ((-1.0)*new_r21));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[8];
IkReal x230=IKsin(j18);
IkReal x231=IKcos(j18);
IkReal x232=((1.0)*x231);
evalcond[0]=(x230+new_r20);
evalcond[1]=(x231+new_r21);
evalcond[2]=(((sj16*x230))+new_r11);
evalcond[3]=(((cj16*x230))+new_r01);
evalcond[4]=(((new_r02*x231))+new_r10);
evalcond[5]=((((-1.0)*cj16*x232))+new_r00);
evalcond[6]=(x230+((cj16*new_r01))+((new_r11*sj16)));
evalcond[7]=((((-1.0)*x232))+((cj16*new_r00))+((new_r10*sj16)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j18eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j18eval[0]=IKabs(new_r22);
if( IKabs(j18eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j18]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=new_r22;
op[1]=0;
op[2]=((-1.0)*new_r22);
polyroots2(op,zeror,numroots);
IkReal j18array[2], cj18array[2], sj18array[2], tempj18array[1];
int numsolutions = 0;
for(int ij18 = 0; ij18 < numroots; ++ij18)
{
IkReal htj18 = zeror[ij18];
tempj18array[0]=((2.0)*(atan(htj18)));
for(int kj18 = 0; kj18 < 1; ++kj18)
{
j18array[numsolutions] = tempj18array[kj18];
if( j18array[numsolutions] > IKPI )
{
    j18array[numsolutions]-=IK2PI;
}
else if( j18array[numsolutions] < -IKPI )
{
    j18array[numsolutions]+=IK2PI;
}
sj18array[numsolutions] = IKsin(j18array[numsolutions]);
cj18array[numsolutions] = IKcos(j18array[numsolutions]);
numsolutions++;
}
}
bool j18valid[2]={true,true};
_nj18 = 2;
for(int ij18 = 0; ij18 < numsolutions; ++ij18)
    {
if( !j18valid[ij18] )
{
    continue;
}
    j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
htj18 = IKtan(j18/2);

_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < numsolutions; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j18]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x234=IKPowWithIntegerCheck(cj17,-1);
if(!x234.valid){
continue;
}
IkReal x233=x234.value;
CheckValue<IkReal> x235=IKPowWithIntegerCheck(sj16,-1);
if(!x235.valid){
continue;
}
CheckValue<IkReal> x236=IKPowWithIntegerCheck(sj17,-1);
if(!x236.valid){
continue;
}
if( IKabs((new_r20*x233)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x233*(x235.value)*(x236.value)*((((cj16*new_r20))+((cj17*new_r01)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r20*x233))+IKsqr((x233*(x235.value)*(x236.value)*((((cj16*new_r20))+((cj17*new_r01))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2((new_r20*x233), (x233*(x235.value)*(x236.value)*((((cj16*new_r20))+((cj17*new_r01))))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[12];
IkReal x237=IKsin(j18);
IkReal x238=IKcos(j18);
IkReal x239=(new_r00*sj16);
IkReal x240=(cj16*new_r10);
IkReal x241=(cj16*sj17);
IkReal x242=(new_r01*sj16);
IkReal x243=((1.0)*sj17);
IkReal x244=((1.0)*x238);
IkReal x245=(cj16*x237);
IkReal x246=(sj16*x237);
IkReal x247=((1.0)*x237);
evalcond[0]=(new_r20+(((-1.0)*cj17*x247)));
evalcond[1]=(new_r21+(((-1.0)*cj17*x244)));
evalcond[2]=(x237+((cj16*new_r01))+((new_r11*sj16)));
evalcond[3]=((((-1.0)*x244))+((cj16*new_r00))+((new_r10*sj16)));
evalcond[4]=(((x238*x241))+x246+new_r11);
evalcond[5]=(((sj17*x237))+x240+(((-1.0)*x239)));
evalcond[6]=((((-1.0)*x242))+((sj17*x238))+((cj16*new_r11)));
evalcond[7]=(x245+new_r01+(((-1.0)*sj16*x238*x243)));
evalcond[8]=(((x237*x241))+(((-1.0)*sj16*x244))+new_r10);
evalcond[9]=((((-1.0)*x243*x246))+(((-1.0)*cj16*x244))+new_r00);
evalcond[10]=(((cj17*new_r20))+((sj17*x239))+(((-1.0)*x240*x243))+(((-1.0)*x247)));
evalcond[11]=(((sj17*x242))+((cj17*new_r21))+(((-1.0)*new_r11*x241))+(((-1.0)*x244)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x249=IKPowWithIntegerCheck(cj17,-1);
if(!x249.valid){
continue;
}
IkReal x248=x249.value;
CheckValue<IkReal> x250=IKPowWithIntegerCheck(sj16,-1);
if(!x250.valid){
continue;
}
if( IKabs((x248*(x250.value)*(((((-1.0)*cj16*new_r21*sj17))+(((-1.0)*cj17*new_r11)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r21*x248)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x248*(x250.value)*(((((-1.0)*cj16*new_r21*sj17))+(((-1.0)*cj17*new_r11))))))+IKsqr((new_r21*x248))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2((x248*(x250.value)*(((((-1.0)*cj16*new_r21*sj17))+(((-1.0)*cj17*new_r11))))), (new_r21*x248));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[12];
IkReal x251=IKsin(j18);
IkReal x252=IKcos(j18);
IkReal x253=(new_r00*sj16);
IkReal x254=(cj16*new_r10);
IkReal x255=(cj16*sj17);
IkReal x256=(new_r01*sj16);
IkReal x257=((1.0)*sj17);
IkReal x258=((1.0)*x252);
IkReal x259=(cj16*x251);
IkReal x260=(sj16*x251);
IkReal x261=((1.0)*x251);
evalcond[0]=(new_r20+(((-1.0)*cj17*x261)));
evalcond[1]=((((-1.0)*cj17*x258))+new_r21);
evalcond[2]=(x251+((cj16*new_r01))+((new_r11*sj16)));
evalcond[3]=(((cj16*new_r00))+((new_r10*sj16))+(((-1.0)*x258)));
evalcond[4]=(x260+((x252*x255))+new_r11);
evalcond[5]=(x254+(((-1.0)*x253))+((sj17*x251)));
evalcond[6]=(((cj16*new_r11))+(((-1.0)*x256))+((sj17*x252)));
evalcond[7]=((((-1.0)*sj16*x252*x257))+x259+new_r01);
evalcond[8]=(((x251*x255))+(((-1.0)*sj16*x258))+new_r10);
evalcond[9]=((((-1.0)*cj16*x258))+new_r00+(((-1.0)*x257*x260)));
evalcond[10]=(((cj17*new_r20))+(((-1.0)*x254*x257))+(((-1.0)*x261))+((sj17*x253)));
evalcond[11]=((((-1.0)*new_r11*x255))+((cj17*new_r21))+((sj17*x256))+(((-1.0)*x258)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x262=IKPowWithIntegerCheck(IKsign(cj17),-1);
if(!x262.valid){
continue;
}
CheckValue<IkReal> x263 = IKatan2WithCheck(IkReal(new_r20),IkReal(new_r21),IKFAST_ATAN2_MAGTHRESH);
if(!x263.valid){
continue;
}
j18array[0]=((-1.5707963267949)+(((1.5707963267949)*(x262.value)))+(x263.value));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[12];
IkReal x264=IKsin(j18);
IkReal x265=IKcos(j18);
IkReal x266=(new_r00*sj16);
IkReal x267=(cj16*new_r10);
IkReal x268=(cj16*sj17);
IkReal x269=(new_r01*sj16);
IkReal x270=((1.0)*sj17);
IkReal x271=((1.0)*x265);
IkReal x272=(cj16*x264);
IkReal x273=(sj16*x264);
IkReal x274=((1.0)*x264);
evalcond[0]=(new_r20+(((-1.0)*cj17*x274)));
evalcond[1]=(new_r21+(((-1.0)*cj17*x271)));
evalcond[2]=(x264+((cj16*new_r01))+((new_r11*sj16)));
evalcond[3]=((((-1.0)*x271))+((cj16*new_r00))+((new_r10*sj16)));
evalcond[4]=(x273+new_r11+((x265*x268)));
evalcond[5]=((((-1.0)*x266))+((sj17*x264))+x267);
evalcond[6]=((((-1.0)*x269))+((sj17*x265))+((cj16*new_r11)));
evalcond[7]=((((-1.0)*sj16*x265*x270))+x272+new_r01);
evalcond[8]=(((x264*x268))+(((-1.0)*sj16*x271))+new_r10);
evalcond[9]=((((-1.0)*cj16*x271))+(((-1.0)*x270*x273))+new_r00);
evalcond[10]=(((sj17*x266))+((cj17*new_r20))+(((-1.0)*x274))+(((-1.0)*x267*x270)));
evalcond[11]=(((sj17*x269))+((cj17*new_r21))+(((-1.0)*new_r11*x268))+(((-1.0)*x271)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x275=IKPowWithIntegerCheck(IKsign(cj17),-1);
if(!x275.valid){
continue;
}
CheckValue<IkReal> x276 = IKatan2WithCheck(IkReal(new_r02),IkReal(((-1.0)*new_r12)),IKFAST_ATAN2_MAGTHRESH);
if(!x276.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x275.value)))+(x276.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x277=IKcos(j16);
IkReal x278=IKsin(j16);
IkReal x279=(new_r12*x277);
IkReal x280=(cj17*x277);
IkReal x281=((1.0)*x278);
evalcond[0]=(x280+new_r12);
evalcond[1]=((((-1.0)*cj17*x281))+new_r02);
evalcond[2]=(((new_r02*x277))+((new_r12*x278)));
evalcond[3]=((((-1.0)*new_r02*x281))+cj17+x279);
evalcond[4]=((((-1.0)*cj17*new_r00*x281))+((new_r20*sj17))+((new_r10*x280)));
evalcond[5]=((((-1.0)*cj17*new_r01*x281))+((new_r21*sj17))+((new_r11*x280)));
evalcond[6]=(((cj17*new_r22))+((new_r02*sj17*x278))+(((-1.0)*sj17*x279)));
evalcond[7]=((1.0)+((new_r22*sj17))+((cj17*x279))+(((-1.0)*cj17*new_r02*x281)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j18eval[3];
j18eval[0]=cj17;
j18eval[1]=IKsign(cj17);
j18eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j18eval[0]) < 0.0000010000000000  || IKabs(j18eval[1]) < 0.0000010000000000  || IKabs(j18eval[2]) < 0.0000010000000000  )
{
{
IkReal j18eval[2];
j18eval[0]=cj17;
j18eval[1]=sj16;
if( IKabs(j18eval[0]) < 0.0000010000000000  || IKabs(j18eval[1]) < 0.0000010000000000  )
{
{
IkReal j18eval[3];
j18eval[0]=cj17;
j18eval[1]=sj16;
j18eval[2]=sj17;
if( IKabs(j18eval[0]) < 0.0000010000000000  || IKabs(j18eval[1]) < 0.0000010000000000  || IKabs(j18eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x282=((1.0)*cj16);
if( IKabs(((((-1.0)*new_r11*sj16))+(((-1.0)*new_r01*x282)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r11*x282))+((new_r01*sj16)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*sj16))+(((-1.0)*new_r01*x282))))+IKsqr(((((-1.0)*new_r11*x282))+((new_r01*sj16))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-1.0)*new_r11*sj16))+(((-1.0)*new_r01*x282))), ((((-1.0)*new_r11*x282))+((new_r01*sj16))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[8];
IkReal x283=IKsin(j18);
IkReal x284=IKcos(j18);
IkReal x285=((1.0)*sj16);
IkReal x286=(cj16*x283);
IkReal x287=(cj16*x284);
IkReal x288=(x284*x285);
evalcond[0]=(x283+((cj16*new_r01))+((new_r11*sj16)));
evalcond[1]=((((-1.0)*new_r00*x285))+x283+((cj16*new_r10)));
evalcond[2]=(x284+(((-1.0)*new_r01*x285))+((cj16*new_r11)));
evalcond[3]=((((-1.0)*x284))+((cj16*new_r00))+((new_r10*sj16)));
evalcond[4]=(x287+new_r11+((sj16*x283)));
evalcond[5]=(x286+(((-1.0)*x288))+new_r01);
evalcond[6]=(x286+(((-1.0)*x288))+new_r10);
evalcond[7]=((((-1.0)*x287))+new_r00+(((-1.0)*x283*x285)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x289=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj16*x289))+(((-1.0)*new_r11*sj16)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj16*new_r11))+(((-1.0)*sj16*x289)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj16*x289))+(((-1.0)*new_r11*sj16))))+IKsqr((((cj16*new_r11))+(((-1.0)*sj16*x289))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-1.0)*cj16*x289))+(((-1.0)*new_r11*sj16))), (((cj16*new_r11))+(((-1.0)*sj16*x289))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[8];
IkReal x290=IKcos(j18);
IkReal x291=IKsin(j18);
IkReal x292=((1.0)*sj16);
IkReal x293=((1.0)*x290);
IkReal x294=(sj16*x291);
IkReal x295=(cj16*x291);
IkReal x296=(sj16*x290);
IkReal x297=(cj16*x293);
evalcond[0]=(x291+((cj16*new_r01))+((new_r11*sj16)));
evalcond[1]=((((-1.0)*x293))+((cj16*new_r00))+((new_r10*sj16)));
evalcond[2]=(x295+x296+new_r01);
evalcond[3]=((((-1.0)*x297))+x294+new_r11);
evalcond[4]=((((-1.0)*x291))+(((-1.0)*new_r00*x292))+((cj16*new_r10)));
evalcond[5]=((((-1.0)*new_r01*x292))+(((-1.0)*x293))+((cj16*new_r11)));
evalcond[6]=((((-1.0)*x297))+x294+new_r00);
evalcond[7]=((((-1.0)*x295))+(((-1.0)*x290*x292))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j16))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-1.0)*new_r01), new_r00);
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[8];
IkReal x298=IKcos(j18);
IkReal x299=IKsin(j18);
IkReal x300=((1.0)*sj17);
IkReal x301=((1.0)*x298);
IkReal x302=((1.0)*x299);
evalcond[0]=(x299+new_r01);
evalcond[1]=(new_r00+(((-1.0)*x301)));
evalcond[2]=(((sj17*x298))+new_r11);
evalcond[3]=(((sj17*x299))+new_r10);
evalcond[4]=(new_r20+(((-1.0)*cj17*x302)));
evalcond[5]=(new_r21+(((-1.0)*cj17*x301)));
evalcond[6]=(((cj17*new_r20))+(((-1.0)*x302))+(((-1.0)*new_r10*x300)));
evalcond[7]=(((cj17*new_r21))+(((-1.0)*new_r11*x300))+(((-1.0)*x301)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j16)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(new_r01, ((-1.0)*new_r00));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[8];
IkReal x303=IKsin(j18);
IkReal x304=IKcos(j18);
IkReal x305=((1.0)*x304);
IkReal x306=((1.0)*x303);
evalcond[0]=(x303+(((-1.0)*new_r01)));
evalcond[1]=(new_r20+(((-1.0)*cj17*x306)));
evalcond[2]=(new_r21+(((-1.0)*cj17*x305)));
evalcond[3]=(new_r11+(((-1.0)*sj17*x305)));
evalcond[4]=((((-1.0)*new_r00))+(((-1.0)*x305)));
evalcond[5]=(((sj17*x303))+(((-1.0)*new_r10)));
evalcond[6]=(((cj17*new_r20))+((new_r10*sj17))+(((-1.0)*x306)));
evalcond[7]=(((cj17*new_r21))+((new_r11*sj17))+(((-1.0)*x305)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(new_r20, new_r21);
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[8];
IkReal x307=IKsin(j18);
IkReal x308=IKcos(j18);
IkReal x309=((1.0)*x308);
evalcond[0]=((((-1.0)*x307))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x309)));
evalcond[2]=(((sj16*x307))+new_r11);
evalcond[3]=(((cj16*x307))+new_r01);
evalcond[4]=((((-1.0)*new_r02*x309))+new_r10);
evalcond[5]=((((-1.0)*cj16*x309))+new_r00);
evalcond[6]=(x307+((cj16*new_r01))+((new_r11*sj16)));
evalcond[7]=(((cj16*new_r00))+((new_r10*sj16))+(((-1.0)*x309)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20))+IKsqr(((-1.0)*new_r21))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-1.0)*new_r20), ((-1.0)*new_r21));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[8];
IkReal x310=IKsin(j18);
IkReal x311=IKcos(j18);
IkReal x312=((1.0)*x311);
evalcond[0]=(x310+new_r20);
evalcond[1]=(x311+new_r21);
evalcond[2]=(((sj16*x310))+new_r11);
evalcond[3]=(((cj16*x310))+new_r01);
evalcond[4]=(((new_r02*x311))+new_r10);
evalcond[5]=((((-1.0)*cj16*x312))+new_r00);
evalcond[6]=(x310+((cj16*new_r01))+((new_r11*sj16)));
evalcond[7]=((((-1.0)*x312))+((cj16*new_r00))+((new_r10*sj16)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j18eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j18eval[0]=IKabs(new_r22);
if( IKabs(j18eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j18]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=new_r22;
op[1]=0;
op[2]=((-1.0)*new_r22);
polyroots2(op,zeror,numroots);
IkReal j18array[2], cj18array[2], sj18array[2], tempj18array[1];
int numsolutions = 0;
for(int ij18 = 0; ij18 < numroots; ++ij18)
{
IkReal htj18 = zeror[ij18];
tempj18array[0]=((2.0)*(atan(htj18)));
for(int kj18 = 0; kj18 < 1; ++kj18)
{
j18array[numsolutions] = tempj18array[kj18];
if( j18array[numsolutions] > IKPI )
{
    j18array[numsolutions]-=IK2PI;
}
else if( j18array[numsolutions] < -IKPI )
{
    j18array[numsolutions]+=IK2PI;
}
sj18array[numsolutions] = IKsin(j18array[numsolutions]);
cj18array[numsolutions] = IKcos(j18array[numsolutions]);
numsolutions++;
}
}
bool j18valid[2]={true,true};
_nj18 = 2;
for(int ij18 = 0; ij18 < numsolutions; ++ij18)
    {
if( !j18valid[ij18] )
{
    continue;
}
    j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
htj18 = IKtan(j18/2);

_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < numsolutions; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j18]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x314=IKPowWithIntegerCheck(cj17,-1);
if(!x314.valid){
continue;
}
IkReal x313=x314.value;
CheckValue<IkReal> x315=IKPowWithIntegerCheck(sj16,-1);
if(!x315.valid){
continue;
}
CheckValue<IkReal> x316=IKPowWithIntegerCheck(sj17,-1);
if(!x316.valid){
continue;
}
if( IKabs((new_r20*x313)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x313*(x315.value)*(x316.value)*((((cj16*new_r20))+((cj17*new_r01)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r20*x313))+IKsqr((x313*(x315.value)*(x316.value)*((((cj16*new_r20))+((cj17*new_r01))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2((new_r20*x313), (x313*(x315.value)*(x316.value)*((((cj16*new_r20))+((cj17*new_r01))))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[12];
IkReal x317=IKsin(j18);
IkReal x318=IKcos(j18);
IkReal x319=(new_r00*sj16);
IkReal x320=(cj16*new_r10);
IkReal x321=(cj16*sj17);
IkReal x322=(new_r01*sj16);
IkReal x323=((1.0)*sj17);
IkReal x324=((1.0)*x318);
IkReal x325=(cj16*x317);
IkReal x326=(sj16*x317);
IkReal x327=((1.0)*x317);
evalcond[0]=((((-1.0)*cj17*x327))+new_r20);
evalcond[1]=((((-1.0)*cj17*x324))+new_r21);
evalcond[2]=(x317+((cj16*new_r01))+((new_r11*sj16)));
evalcond[3]=((((-1.0)*x324))+((cj16*new_r00))+((new_r10*sj16)));
evalcond[4]=(((x318*x321))+x326+new_r11);
evalcond[5]=(((sj17*x317))+x320+(((-1.0)*x319)));
evalcond[6]=(((sj17*x318))+(((-1.0)*x322))+((cj16*new_r11)));
evalcond[7]=(x325+new_r01+(((-1.0)*sj16*x318*x323)));
evalcond[8]=((((-1.0)*sj16*x324))+((x317*x321))+new_r10);
evalcond[9]=((((-1.0)*cj16*x324))+(((-1.0)*x323*x326))+new_r00);
evalcond[10]=(((cj17*new_r20))+((sj17*x319))+(((-1.0)*x327))+(((-1.0)*x320*x323)));
evalcond[11]=(((cj17*new_r21))+(((-1.0)*x324))+((sj17*x322))+(((-1.0)*new_r11*x321)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x329=IKPowWithIntegerCheck(cj17,-1);
if(!x329.valid){
continue;
}
IkReal x328=x329.value;
CheckValue<IkReal> x330=IKPowWithIntegerCheck(sj16,-1);
if(!x330.valid){
continue;
}
if( IKabs((x328*(x330.value)*(((((-1.0)*cj16*new_r21*sj17))+(((-1.0)*cj17*new_r11)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r21*x328)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x328*(x330.value)*(((((-1.0)*cj16*new_r21*sj17))+(((-1.0)*cj17*new_r11))))))+IKsqr((new_r21*x328))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2((x328*(x330.value)*(((((-1.0)*cj16*new_r21*sj17))+(((-1.0)*cj17*new_r11))))), (new_r21*x328));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[12];
IkReal x331=IKsin(j18);
IkReal x332=IKcos(j18);
IkReal x333=(new_r00*sj16);
IkReal x334=(cj16*new_r10);
IkReal x335=(cj16*sj17);
IkReal x336=(new_r01*sj16);
IkReal x337=((1.0)*sj17);
IkReal x338=((1.0)*x332);
IkReal x339=(cj16*x331);
IkReal x340=(sj16*x331);
IkReal x341=((1.0)*x331);
evalcond[0]=((((-1.0)*cj17*x341))+new_r20);
evalcond[1]=((((-1.0)*cj17*x338))+new_r21);
evalcond[2]=(x331+((cj16*new_r01))+((new_r11*sj16)));
evalcond[3]=((((-1.0)*x338))+((cj16*new_r00))+((new_r10*sj16)));
evalcond[4]=(((x332*x335))+x340+new_r11);
evalcond[5]=(x334+(((-1.0)*x333))+((sj17*x331)));
evalcond[6]=((((-1.0)*x336))+((sj17*x332))+((cj16*new_r11)));
evalcond[7]=((((-1.0)*sj16*x332*x337))+x339+new_r01);
evalcond[8]=(((x331*x335))+(((-1.0)*sj16*x338))+new_r10);
evalcond[9]=((((-1.0)*x337*x340))+(((-1.0)*cj16*x338))+new_r00);
evalcond[10]=(((cj17*new_r20))+((sj17*x333))+(((-1.0)*x341))+(((-1.0)*x334*x337)));
evalcond[11]=(((cj17*new_r21))+((sj17*x336))+(((-1.0)*x338))+(((-1.0)*new_r11*x335)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x342=IKPowWithIntegerCheck(IKsign(cj17),-1);
if(!x342.valid){
continue;
}
CheckValue<IkReal> x343 = IKatan2WithCheck(IkReal(new_r20),IkReal(new_r21),IKFAST_ATAN2_MAGTHRESH);
if(!x343.valid){
continue;
}
j18array[0]=((-1.5707963267949)+(((1.5707963267949)*(x342.value)))+(x343.value));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[12];
IkReal x344=IKsin(j18);
IkReal x345=IKcos(j18);
IkReal x346=(new_r00*sj16);
IkReal x347=(cj16*new_r10);
IkReal x348=(cj16*sj17);
IkReal x349=(new_r01*sj16);
IkReal x350=((1.0)*sj17);
IkReal x351=((1.0)*x345);
IkReal x352=(cj16*x344);
IkReal x353=(sj16*x344);
IkReal x354=((1.0)*x344);
evalcond[0]=((((-1.0)*cj17*x354))+new_r20);
evalcond[1]=((((-1.0)*cj17*x351))+new_r21);
evalcond[2]=(x344+((cj16*new_r01))+((new_r11*sj16)));
evalcond[3]=((((-1.0)*x351))+((cj16*new_r00))+((new_r10*sj16)));
evalcond[4]=(x353+((x345*x348))+new_r11);
evalcond[5]=(((sj17*x344))+x347+(((-1.0)*x346)));
evalcond[6]=(((sj17*x345))+((cj16*new_r11))+(((-1.0)*x349)));
evalcond[7]=(x352+new_r01+(((-1.0)*sj16*x345*x350)));
evalcond[8]=((((-1.0)*sj16*x351))+((x344*x348))+new_r10);
evalcond[9]=((((-1.0)*cj16*x351))+new_r00+(((-1.0)*x350*x353)));
evalcond[10]=(((cj17*new_r20))+(((-1.0)*x354))+((sj17*x346))+(((-1.0)*x347*x350)));
evalcond[11]=(((cj17*new_r21))+(((-1.0)*x351))+(((-1.0)*new_r11*x348))+((sj17*x349)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x355=IKPowWithIntegerCheck(IKsign(cj17),-1);
if(!x355.valid){
continue;
}
CheckValue<IkReal> x356 = IKatan2WithCheck(IkReal(new_r20),IkReal(new_r21),IKFAST_ATAN2_MAGTHRESH);
if(!x356.valid){
continue;
}
j18array[0]=((-1.5707963267949)+(((1.5707963267949)*(x355.value)))+(x356.value));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[2];
IkReal x357=((1.0)*cj17);
evalcond[0]=((((-1.0)*x357*(IKsin(j18))))+new_r20);
evalcond[1]=((((-1.0)*x357*(IKcos(j18))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j16eval[3];
j16eval[0]=cj17;
j16eval[1]=IKsign(cj17);
j16eval[2]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[2];
j16eval[0]=cj17;
j16eval[1]=new_r11;
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[3];
sj17=1.0;
cj17=0;
j17=1.5707963267949;
IkReal x358=((1.0)*sj18);
IkReal x359=(((new_r10*new_r11))+((new_r00*new_r01)));
j16eval[0]=x359;
j16eval[1]=((IKabs(((((-1.0)*new_r11*x358))+(((-1.0)*new_r00*x358)))))+(IKabs((((new_r01*sj18))+(((-1.0)*new_r10*x358))))));
j16eval[2]=IKsign(x359);
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
sj17=1.0;
cj17=0;
j17=1.5707963267949;
IkReal x360=((1.0)*sj18);
IkReal x361=((new_r01*new_r01)+(new_r11*new_r11));
j16eval[0]=x361;
j16eval[1]=((IKabs(((((-1.0)*new_r11*x360))+((cj18*new_r01)))))+(IKabs(((((-1.0)*cj18*new_r11))+(((-1.0)*new_r01*x360))))));
j16eval[2]=IKsign(x361);
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
sj17=1.0;
cj17=0;
j17=1.5707963267949;
IkReal x362=(((cj18*new_r01))+((new_r11*sj18)));
j16eval[0]=x362;
j16eval[1]=((IKabs(((((-1.0)*new_r01*new_r11))+(((-1.0)*cj18*sj18)))))+(IKabs(((-1.0)+(new_r01*new_r01)+(cj18*cj18)))));
j16eval[2]=IKsign(x362);
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x364 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x364)==0){
continue;
}
IkReal x363=pow(x364,-0.5);
CheckValue<IkReal> x365 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x365.valid){
continue;
}
IkReal gconst0=((-1.0)*(x365.value));
IkReal gconst1=((-1.0)*new_r01*x363);
IkReal gconst2=(new_r11*x363);
CheckValue<IkReal> x366 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x366.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j18+(x366.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[3];
CheckValue<IkReal> x369 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x369.valid){
continue;
}
IkReal x367=((-1.0)*(x369.value));
IkReal x368=x363;
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst1;
cj18=gconst2;
j18=x367;
IkReal gconst0=x367;
IkReal gconst1=((-1.0)*new_r01*x368);
IkReal gconst2=(new_r11*x368);
IkReal x370=new_r01*new_r01;
IkReal x371=(new_r00*new_r01);
IkReal x372=(((new_r10*new_r11))+x371);
IkReal x373=x363;
IkReal x374=(new_r01*x373);
j16eval[0]=x372;
j16eval[1]=((IKabs(((((-1.0)*x370*x373))+((new_r10*x374)))))+(IKabs((((new_r11*x374))+((x371*x373))))));
j16eval[2]=IKsign(x372);
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[2];
CheckValue<IkReal> x377 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x377.valid){
continue;
}
IkReal x375=((-1.0)*(x377.value));
IkReal x376=x363;
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst1;
cj18=gconst2;
j18=x375;
IkReal gconst0=x375;
IkReal gconst1=((-1.0)*new_r01*x376);
IkReal gconst2=(new_r11*x376);
IkReal x378=((new_r01*new_r01)+(new_r11*new_r11));
j16eval[0]=x378;
j16eval[1]=IKsign(x378);
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
CheckValue<IkReal> x381 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x381.valid){
continue;
}
IkReal x379=((-1.0)*(x381.value));
IkReal x380=x363;
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst1;
cj18=gconst2;
j18=x379;
IkReal gconst0=x379;
IkReal gconst1=((-1.0)*new_r01*x380);
IkReal gconst2=(new_r11*x380);
IkReal x382=new_r01*new_r01;
IkReal x383=new_r11*new_r11;
IkReal x384=((1.0)*x382);
CheckValue<IkReal> x390=IKPowWithIntegerCheck((x382+x383),-1);
if(!x390.valid){
continue;
}
IkReal x385=x390.value;
CheckValue<IkReal> x391=IKPowWithIntegerCheck(((((-1.0)*x383))+(((-1.0)*x384))),-1);
if(!x391.valid){
continue;
}
IkReal x386=x391.value;
IkReal x387=((1.0)*x386);
IkReal x388=(new_r11*x387);
IkReal x389=(new_r01*x387);
j16eval[0]=((IKabs(((((-1.0)*x388*(new_r01*new_r01*new_r01)))+(((-1.0)*new_r01*x388))+(((-1.0)*new_r01*x388*(new_r11*new_r11))))))+(IKabs((((x382*x383*x385))+((x385*(x383*x383)))+(((-1.0)*x384*x385))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[1];
CheckValue<IkReal> x393 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x393.valid){
continue;
}
IkReal x392=((-1.0)*(x393.value));
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst1;
cj18=gconst2;
j18=x392;
new_r11=0;
new_r00=0;
IkReal gconst0=x392;
IkReal x394 = new_r01*new_r01;
if(IKabs(x394)==0){
continue;
}
IkReal gconst1=((-1.0)*new_r01*(pow(x394,-0.5)));
IkReal gconst2=0;
j16eval[0]=new_r01;
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
CheckValue<IkReal> x396 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x396.valid){
continue;
}
IkReal x395=((-1.0)*(x396.value));
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst1;
cj18=gconst2;
j18=x395;
new_r11=0;
new_r00=0;
IkReal gconst0=x395;
IkReal x397 = new_r01*new_r01;
if(IKabs(x397)==0){
continue;
}
IkReal gconst1=((-1.0)*new_r01*(pow(x397,-0.5)));
IkReal gconst2=0;
j16eval[0]=new_r10;
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x398=IKPowWithIntegerCheck(gconst1,-1);
if(!x398.valid){
continue;
}
cj16array[0]=((-1.0)*new_r01*(x398.value));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x399=IKsin(j16);
IkReal x400=IKcos(j16);
evalcond[0]=(new_r10*x399);
evalcond[1]=(gconst1*x399);
evalcond[2]=((-1.0)*new_r01*x399);
evalcond[3]=(gconst1+((new_r01*x400)));
evalcond[4]=(gconst1+((new_r10*x400)));
evalcond[5]=(((gconst1*x400))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x401=IKPowWithIntegerCheck(new_r10,-1);
if(!x401.valid){
continue;
}
cj16array[0]=((-1.0)*gconst1*(x401.value));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x402=IKsin(j16);
IkReal x403=IKcos(j16);
IkReal x404=(gconst1*x403);
evalcond[0]=(new_r10*x402);
evalcond[1]=(gconst1*x402);
evalcond[2]=((-1.0)*new_r01*x402);
evalcond[3]=(gconst1+((new_r01*x403)));
evalcond[4]=(x404+new_r01);
evalcond[5]=(x404+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x405=IKPowWithIntegerCheck(new_r01,-1);
if(!x405.valid){
continue;
}
cj16array[0]=((-1.0)*gconst1*(x405.value));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x406=IKsin(j16);
IkReal x407=IKcos(j16);
IkReal x408=(gconst1*x407);
evalcond[0]=(new_r10*x406);
evalcond[1]=(gconst1*x406);
evalcond[2]=((-1.0)*new_r01*x406);
evalcond[3]=(gconst1+((new_r10*x407)));
evalcond[4]=(x408+new_r01);
evalcond[5]=(x408+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst1;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[3];
CheckValue<IkReal> x410 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x410.valid){
continue;
}
IkReal x409=((-1.0)*(x410.value));
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst1;
cj18=gconst2;
j18=x409;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst0=x409;
IkReal gconst1=((-1.0)*new_r01);
IkReal gconst2=new_r11;
j16eval[0]=-1.0;
j16eval[1]=((IKabs(new_r01*new_r01))+(IKabs((new_r01*new_r11))));
j16eval[2]=-1.0;
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
CheckValue<IkReal> x412 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x412.valid){
continue;
}
IkReal x411=((-1.0)*(x412.value));
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst1;
cj18=gconst2;
j18=x411;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst0=x411;
IkReal gconst1=((-1.0)*new_r01);
IkReal gconst2=new_r11;
j16eval[0]=-1.0;
j16eval[1]=-1.0;
j16eval[2]=((IKabs((new_r01*new_r11)))+(IKabs(((1.0)+(((-1.0)*(new_r01*new_r01)))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
CheckValue<IkReal> x414 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x414.valid){
continue;
}
IkReal x413=((-1.0)*(x414.value));
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst1;
cj18=gconst2;
j18=x413;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst0=x413;
IkReal gconst1=((-1.0)*new_r01);
IkReal gconst2=new_r11;
j16eval[0]=1.0;
j16eval[1]=((((0.5)*(IKabs(((-1.0)+(((2.0)*(new_r01*new_r01))))))))+(IKabs((new_r01*new_r11))));
j16eval[2]=1.0;
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x415=((1.0)*new_r11);
CheckValue<IkReal> x416=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x416.valid){
continue;
}
CheckValue<IkReal> x417 = IKatan2WithCheck(IkReal(((((-1.0)*gconst1*x415))+((gconst2*new_r01)))),IkReal(((((-1.0)*gconst1*new_r01))+(((-1.0)*gconst2*x415)))),IKFAST_ATAN2_MAGTHRESH);
if(!x417.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x416.value)))+(x417.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x418=IKsin(j16);
IkReal x419=IKcos(j16);
IkReal x420=(gconst1*x419);
IkReal x421=(gconst2*x419);
IkReal x422=(gconst1*x418);
IkReal x423=((1.0)*x418);
IkReal x424=(gconst2*x423);
evalcond[0]=(gconst1+((new_r11*x418))+((new_r01*x419)));
evalcond[1]=(x422+x421+new_r11);
evalcond[2]=((((-1.0)*x424))+x420);
evalcond[3]=(gconst2+((new_r11*x419))+(((-1.0)*new_r01*x423)));
evalcond[4]=((((-1.0)*x424))+x420+new_r01);
evalcond[5]=((((-1.0)*x422))+(((-1.0)*x421)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x425=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst2*gconst2)))+(((-1.0)*(gconst1*gconst1))))),-1);
if(!x425.valid){
continue;
}
CheckValue<IkReal> x426 = IKatan2WithCheck(IkReal((gconst1*new_r11)),IkReal((gconst2*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x426.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x425.value)))+(x426.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x427=IKsin(j16);
IkReal x428=IKcos(j16);
IkReal x429=(gconst1*x428);
IkReal x430=(gconst2*x428);
IkReal x431=(gconst1*x427);
IkReal x432=((1.0)*x427);
IkReal x433=(gconst2*x432);
evalcond[0]=(gconst1+((new_r11*x427))+((new_r01*x428)));
evalcond[1]=(x430+x431+new_r11);
evalcond[2]=((((-1.0)*x433))+x429);
evalcond[3]=((((-1.0)*new_r01*x432))+gconst2+((new_r11*x428)));
evalcond[4]=((((-1.0)*x433))+x429+new_r01);
evalcond[5]=((((-1.0)*x430))+(((-1.0)*x431)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x434=IKPowWithIntegerCheck(IKsign((((gconst1*new_r01))+(((-1.0)*gconst2*new_r11)))),-1);
if(!x434.valid){
continue;
}
CheckValue<IkReal> x435 = IKatan2WithCheck(IkReal((gconst1*gconst2)),IkReal(((-1.0)*(gconst1*gconst1))),IKFAST_ATAN2_MAGTHRESH);
if(!x435.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x434.value)))+(x435.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x436=IKsin(j16);
IkReal x437=IKcos(j16);
IkReal x438=(gconst1*x437);
IkReal x439=(gconst2*x437);
IkReal x440=(gconst1*x436);
IkReal x441=((1.0)*x436);
IkReal x442=(gconst2*x441);
evalcond[0]=(((new_r01*x437))+gconst1+((new_r11*x436)));
evalcond[1]=(x439+x440+new_r11);
evalcond[2]=((((-1.0)*x442))+x438);
evalcond[3]=((((-1.0)*new_r01*x441))+gconst2+((new_r11*x437)));
evalcond[4]=((((-1.0)*x442))+x438+new_r01);
evalcond[5]=((((-1.0)*x439))+(((-1.0)*x440)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x443=IKPowWithIntegerCheck(gconst2,-1);
if(!x443.valid){
continue;
}
cj16array[0]=(new_r00*(x443.value));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x444=IKsin(j16);
IkReal x445=IKcos(j16);
IkReal x446=((-1.0)*x444);
evalcond[0]=(new_r11*x444);
evalcond[1]=(new_r00*x446);
evalcond[2]=(gconst2*x446);
evalcond[3]=(((gconst2*x445))+new_r11);
evalcond[4]=(gconst2+((new_r11*x445)));
evalcond[5]=(((new_r00*x445))+(((-1.0)*gconst2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[1];
CheckValue<IkReal> x448 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x448.valid){
continue;
}
IkReal x447=((-1.0)*(x448.value));
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst1;
cj18=gconst2;
j18=x447;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst0=x447;
IkReal gconst1=0;
IkReal x449 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x449)==0){
continue;
}
IkReal gconst2=(new_r11*(pow(x449,-0.5)));
j16eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
CheckValue<IkReal> x451 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x451.valid){
continue;
}
IkReal x450=((-1.0)*(x451.value));
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst1;
cj18=gconst2;
j18=x450;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst0=x450;
IkReal gconst1=0;
IkReal x452 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x452)==0){
continue;
}
IkReal gconst2=(new_r11*(pow(x452,-0.5)));
j16eval[0]=new_r11;
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
CheckValue<IkReal> x454 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x454.valid){
continue;
}
IkReal x453=((-1.0)*(x454.value));
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst1;
cj18=gconst2;
j18=x453;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst0=x453;
IkReal gconst1=0;
IkReal x455 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x455)==0){
continue;
}
IkReal gconst2=(new_r11*(pow(x455,-0.5)));
j16eval[0]=new_r10;
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x456=IKPowWithIntegerCheck(new_r10,-1);
if(!x456.valid){
continue;
}
CheckValue<IkReal> x457=IKPowWithIntegerCheck(gconst2,-1);
if(!x457.valid){
continue;
}
if( IKabs((gconst2*(x456.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11*(x457.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst2*(x456.value)))+IKsqr(((-1.0)*new_r11*(x457.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2((gconst2*(x456.value)), ((-1.0)*new_r11*(x457.value)));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x458=IKsin(j16);
IkReal x459=IKcos(j16);
IkReal x460=((1.0)*gconst2);
IkReal x461=((-1.0)*gconst2);
evalcond[0]=(new_r11*x458);
evalcond[1]=(new_r10*x459);
evalcond[2]=(x458*x461);
evalcond[3]=(x459*x461);
evalcond[4]=(new_r11+((gconst2*x459)));
evalcond[5]=(((new_r11*x459))+gconst2);
evalcond[6]=((((-1.0)*x458*x460))+new_r10);
evalcond[7]=(((new_r10*x458))+(((-1.0)*x460)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x462=IKPowWithIntegerCheck(gconst2,-1);
if(!x462.valid){
continue;
}
CheckValue<IkReal> x463=IKPowWithIntegerCheck(new_r11,-1);
if(!x463.valid){
continue;
}
if( IKabs((new_r10*(x462.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst2*(x463.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x462.value)))+IKsqr(((-1.0)*gconst2*(x463.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2((new_r10*(x462.value)), ((-1.0)*gconst2*(x463.value)));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x464=IKsin(j16);
IkReal x465=IKcos(j16);
IkReal x466=((1.0)*gconst2);
IkReal x467=((-1.0)*gconst2);
evalcond[0]=(new_r11*x464);
evalcond[1]=(new_r10*x465);
evalcond[2]=(x464*x467);
evalcond[3]=(x465*x467);
evalcond[4]=(((gconst2*x465))+new_r11);
evalcond[5]=(((new_r11*x465))+gconst2);
evalcond[6]=((((-1.0)*x464*x466))+new_r10);
evalcond[7]=(((new_r10*x464))+(((-1.0)*x466)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x468 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x468.valid){
continue;
}
CheckValue<IkReal> x469=IKPowWithIntegerCheck(IKsign(gconst2),-1);
if(!x469.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x468.value)+(((1.5707963267949)*(x469.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x470=IKsin(j16);
IkReal x471=IKcos(j16);
IkReal x472=((1.0)*gconst2);
IkReal x473=((-1.0)*gconst2);
evalcond[0]=(new_r11*x470);
evalcond[1]=(new_r10*x471);
evalcond[2]=(x470*x473);
evalcond[3]=(x471*x473);
evalcond[4]=(((gconst2*x471))+new_r11);
evalcond[5]=(gconst2+((new_r11*x471)));
evalcond[6]=(new_r10+(((-1.0)*x470*x472)));
evalcond[7]=(((new_r10*x470))+(((-1.0)*x472)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[1];
CheckValue<IkReal> x475 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x475.valid){
continue;
}
IkReal x474=((-1.0)*(x475.value));
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst1;
cj18=gconst2;
j18=x474;
new_r01=0;
IkReal gconst0=x474;
IkReal gconst1=0;
IkReal x476 = new_r11*new_r11;
if(IKabs(x476)==0){
continue;
}
IkReal gconst2=(new_r11*(pow(x476,-0.5)));
j16eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
CheckValue<IkReal> x478 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x478.valid){
continue;
}
IkReal x477=((-1.0)*(x478.value));
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst1;
cj18=gconst2;
j18=x477;
new_r01=0;
IkReal gconst0=x477;
IkReal gconst1=0;
IkReal x479 = new_r11*new_r11;
if(IKabs(x479)==0){
continue;
}
IkReal gconst2=(new_r11*(pow(x479,-0.5)));
j16eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
CheckValue<IkReal> x481 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x481.valid){
continue;
}
IkReal x480=((-1.0)*(x481.value));
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst1;
cj18=gconst2;
j18=x480;
new_r01=0;
IkReal gconst0=x480;
IkReal gconst1=0;
IkReal x482 = new_r11*new_r11;
if(IKabs(x482)==0){
continue;
}
IkReal gconst2=(new_r11*(pow(x482,-0.5)));
j16eval[0]=new_r11;
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x483=IKPowWithIntegerCheck(gconst2,-1);
if(!x483.valid){
continue;
}
CheckValue<IkReal> x484=IKPowWithIntegerCheck(new_r11,-1);
if(!x484.valid){
continue;
}
if( IKabs((new_r10*(x483.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst2*(x484.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x483.value)))+IKsqr(((-1.0)*gconst2*(x484.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2((new_r10*(x483.value)), ((-1.0)*gconst2*(x484.value)));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x485=IKsin(j16);
IkReal x486=IKcos(j16);
IkReal x487=(gconst2*x485);
IkReal x488=(gconst2*x486);
evalcond[0]=(new_r11*x485);
evalcond[1]=((-1.0)*x487);
evalcond[2]=(x488+new_r11);
evalcond[3]=(((new_r11*x486))+gconst2);
evalcond[4]=((((-1.0)*x487))+new_r10);
evalcond[5]=((((-1.0)*x488))+new_r00);
evalcond[6]=(((new_r10*x486))+(((-1.0)*new_r00*x485)));
evalcond[7]=((((-1.0)*gconst2))+((new_r10*x485))+((new_r00*x486)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x489 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x489.valid){
continue;
}
CheckValue<IkReal> x490=IKPowWithIntegerCheck(IKsign(gconst2),-1);
if(!x490.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x489.value)+(((1.5707963267949)*(x490.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x491=IKsin(j16);
IkReal x492=IKcos(j16);
IkReal x493=(gconst2*x491);
IkReal x494=(gconst2*x492);
evalcond[0]=(new_r11*x491);
evalcond[1]=((-1.0)*x493);
evalcond[2]=(x494+new_r11);
evalcond[3]=(gconst2+((new_r11*x492)));
evalcond[4]=((((-1.0)*x493))+new_r10);
evalcond[5]=((((-1.0)*x494))+new_r00);
evalcond[6]=(((new_r10*x492))+(((-1.0)*new_r00*x491)));
evalcond[7]=((((-1.0)*gconst2))+((new_r10*x491))+((new_r00*x492)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x495=IKPowWithIntegerCheck(IKsign(gconst2),-1);
if(!x495.valid){
continue;
}
CheckValue<IkReal> x496 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x496.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x495.value)))+(x496.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x497=IKsin(j16);
IkReal x498=IKcos(j16);
IkReal x499=(gconst2*x497);
IkReal x500=(gconst2*x498);
evalcond[0]=(new_r11*x497);
evalcond[1]=((-1.0)*x499);
evalcond[2]=(x500+new_r11);
evalcond[3]=(gconst2+((new_r11*x498)));
evalcond[4]=((((-1.0)*x499))+new_r10);
evalcond[5]=(new_r00+(((-1.0)*x500)));
evalcond[6]=(((new_r10*x498))+(((-1.0)*new_r00*x497)));
evalcond[7]=((((-1.0)*gconst2))+((new_r10*x497))+((new_r00*x498)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j16]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x501=((1.0)*new_r11);
CheckValue<IkReal> x502 = IKatan2WithCheck(IkReal(((((-1.0)*new_r01*x501))+((gconst1*gconst2)))),IkReal(((new_r11*new_r11)+(((-1.0)*(gconst1*gconst1))))),IKFAST_ATAN2_MAGTHRESH);
if(!x502.valid){
continue;
}
CheckValue<IkReal> x503=IKPowWithIntegerCheck(IKsign((((gconst1*new_r01))+(((-1.0)*gconst2*x501)))),-1);
if(!x503.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x502.value)+(((1.5707963267949)*(x503.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x504=IKsin(j16);
IkReal x505=IKcos(j16);
IkReal x506=(gconst1*x505);
IkReal x507=(gconst2*x505);
IkReal x508=((1.0)*x504);
IkReal x509=(gconst2*x508);
evalcond[0]=(gconst1+((new_r11*x504))+((new_r01*x505)));
evalcond[1]=(((gconst1*x504))+x507+new_r11);
evalcond[2]=((((-1.0)*new_r00*x508))+gconst1+((new_r10*x505)));
evalcond[3]=((((-1.0)*new_r01*x508))+gconst2+((new_r11*x505)));
evalcond[4]=((((-1.0)*x509))+x506+new_r01);
evalcond[5]=((((-1.0)*x509))+x506+new_r10);
evalcond[6]=((((-1.0)*gconst2))+((new_r10*x504))+((new_r00*x505)));
evalcond[7]=((((-1.0)*gconst1*x508))+new_r00+(((-1.0)*x507)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x510=((1.0)*new_r11);
CheckValue<IkReal> x511 = IKatan2WithCheck(IkReal((((gconst2*new_r01))+(((-1.0)*gconst1*x510)))),IkReal(((((-1.0)*gconst1*new_r01))+(((-1.0)*gconst2*x510)))),IKFAST_ATAN2_MAGTHRESH);
if(!x511.valid){
continue;
}
CheckValue<IkReal> x512=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x512.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x511.value)+(((1.5707963267949)*(x512.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x513=IKsin(j16);
IkReal x514=IKcos(j16);
IkReal x515=(gconst1*x514);
IkReal x516=(gconst2*x514);
IkReal x517=((1.0)*x513);
IkReal x518=(gconst2*x517);
evalcond[0]=(((new_r01*x514))+((new_r11*x513))+gconst1);
evalcond[1]=(((gconst1*x513))+x516+new_r11);
evalcond[2]=(((new_r10*x514))+gconst1+(((-1.0)*new_r00*x517)));
evalcond[3]=(((new_r11*x514))+gconst2+(((-1.0)*new_r01*x517)));
evalcond[4]=(x515+new_r01+(((-1.0)*x518)));
evalcond[5]=(x515+new_r10+(((-1.0)*x518)));
evalcond[6]=(((new_r00*x514))+((new_r10*x513))+(((-1.0)*gconst2)));
evalcond[7]=((((-1.0)*x516))+(((-1.0)*gconst1*x517))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x519=((1.0)*gconst1);
CheckValue<IkReal> x520=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x520.valid){
continue;
}
CheckValue<IkReal> x521 = IKatan2WithCheck(IkReal(((((-1.0)*new_r10*x519))+((gconst1*new_r01)))),IkReal(((((-1.0)*new_r11*x519))+(((-1.0)*new_r00*x519)))),IKFAST_ATAN2_MAGTHRESH);
if(!x521.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x520.value)))+(x521.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x522=IKsin(j16);
IkReal x523=IKcos(j16);
IkReal x524=(gconst1*x523);
IkReal x525=(gconst2*x523);
IkReal x526=((1.0)*x522);
IkReal x527=(gconst2*x526);
evalcond[0]=(((new_r01*x523))+gconst1+((new_r11*x522)));
evalcond[1]=(x525+((gconst1*x522))+new_r11);
evalcond[2]=(gconst1+(((-1.0)*new_r00*x526))+((new_r10*x523)));
evalcond[3]=(gconst2+((new_r11*x523))+(((-1.0)*new_r01*x526)));
evalcond[4]=((((-1.0)*x527))+x524+new_r01);
evalcond[5]=((((-1.0)*x527))+x524+new_r10);
evalcond[6]=((((-1.0)*gconst2))+((new_r10*x522))+((new_r00*x523)));
evalcond[7]=((((-1.0)*x525))+new_r00+(((-1.0)*gconst1*x526)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x529 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x529)==0){
continue;
}
IkReal x528=pow(x529,-0.5);
CheckValue<IkReal> x530 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x530.valid){
continue;
}
IkReal gconst3=((3.14159265358979)+(((-1.0)*(x530.value))));
IkReal gconst4=((1.0)*new_r01*x528);
IkReal gconst5=((-1.0)*new_r11*x528);
CheckValue<IkReal> x531 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x531.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j18+(x531.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[3];
CheckValue<IkReal> x534 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x534.valid){
continue;
}
IkReal x532=((1.0)*(x534.value));
IkReal x533=x528;
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst4;
cj18=gconst5;
j18=((3.14159265)+(((-1.0)*x532)));
IkReal gconst3=((3.14159265358979)+(((-1.0)*x532)));
IkReal gconst4=((1.0)*new_r01*x533);
IkReal gconst5=((-1.0)*new_r11*x533);
IkReal x535=new_r01*new_r01;
IkReal x536=(((new_r10*new_r11))+((new_r00*new_r01)));
IkReal x537=x528;
IkReal x538=((1.0)*new_r01*x537);
j16eval[0]=x536;
j16eval[1]=IKsign(x536);
j16eval[2]=((IKabs(((((-1.0)*new_r00*x538))+(((-1.0)*new_r11*x538)))))+(IKabs(((((-1.0)*new_r10*x538))+((x535*x537))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[2];
CheckValue<IkReal> x541 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x541.valid){
continue;
}
IkReal x539=((1.0)*(x541.value));
IkReal x540=x528;
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst4;
cj18=gconst5;
j18=((3.14159265)+(((-1.0)*x539)));
IkReal gconst3=((3.14159265358979)+(((-1.0)*x539)));
IkReal gconst4=((1.0)*new_r01*x540);
IkReal gconst5=((-1.0)*new_r11*x540);
IkReal x542=((new_r01*new_r01)+(new_r11*new_r11));
j16eval[0]=x542;
j16eval[1]=IKsign(x542);
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
CheckValue<IkReal> x545 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x545.valid){
continue;
}
IkReal x543=((1.0)*(x545.value));
IkReal x544=x528;
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst4;
cj18=gconst5;
j18=((3.14159265)+(((-1.0)*x543)));
IkReal gconst3=((3.14159265358979)+(((-1.0)*x543)));
IkReal gconst4=((1.0)*new_r01*x544);
IkReal gconst5=((-1.0)*new_r11*x544);
IkReal x546=new_r01*new_r01;
IkReal x547=new_r11*new_r11;
IkReal x548=((1.0)*x546);
CheckValue<IkReal> x554=IKPowWithIntegerCheck((x546+x547),-1);
if(!x554.valid){
continue;
}
IkReal x549=x554.value;
CheckValue<IkReal> x555=IKPowWithIntegerCheck(((((-1.0)*x547))+(((-1.0)*x548))),-1);
if(!x555.valid){
continue;
}
IkReal x550=x555.value;
IkReal x551=((1.0)*x550);
IkReal x552=(new_r11*x551);
IkReal x553=(new_r01*x551);
j16eval[0]=((IKabs(((((-1.0)*x548*x549))+((x546*x547*x549))+((x549*(x547*x547))))))+(IKabs(((((-1.0)*new_r01*x552))+(((-1.0)*x552*(new_r01*new_r01*new_r01)))+(((-1.0)*new_r01*x552*(new_r11*new_r11)))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[1];
CheckValue<IkReal> x557 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x557.valid){
continue;
}
IkReal x556=((1.0)*(x557.value));
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst4;
cj18=gconst5;
j18=((3.14159265)+(((-1.0)*x556)));
new_r11=0;
new_r00=0;
IkReal gconst3=((3.14159265358979)+(((-1.0)*x556)));
IkReal x558 = new_r01*new_r01;
if(IKabs(x558)==0){
continue;
}
IkReal gconst4=((1.0)*new_r01*(pow(x558,-0.5)));
IkReal gconst5=0;
j16eval[0]=new_r01;
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
CheckValue<IkReal> x560 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x560.valid){
continue;
}
IkReal x559=((1.0)*(x560.value));
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst4;
cj18=gconst5;
j18=((3.14159265)+(((-1.0)*x559)));
new_r11=0;
new_r00=0;
IkReal gconst3=((3.14159265358979)+(((-1.0)*x559)));
IkReal x561 = new_r01*new_r01;
if(IKabs(x561)==0){
continue;
}
IkReal gconst4=((1.0)*new_r01*(pow(x561,-0.5)));
IkReal gconst5=0;
j16eval[0]=new_r10;
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x562=IKPowWithIntegerCheck(gconst4,-1);
if(!x562.valid){
continue;
}
cj16array[0]=((-1.0)*new_r01*(x562.value));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x563=IKsin(j16);
IkReal x564=IKcos(j16);
evalcond[0]=(new_r10*x563);
evalcond[1]=(gconst4*x563);
evalcond[2]=((-1.0)*new_r01*x563);
evalcond[3]=(gconst4+((new_r01*x564)));
evalcond[4]=(gconst4+((new_r10*x564)));
evalcond[5]=(((gconst4*x564))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x565=IKPowWithIntegerCheck(new_r10,-1);
if(!x565.valid){
continue;
}
cj16array[0]=((-1.0)*gconst4*(x565.value));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x566=IKsin(j16);
IkReal x567=IKcos(j16);
IkReal x568=(gconst4*x567);
evalcond[0]=(new_r10*x566);
evalcond[1]=(gconst4*x566);
evalcond[2]=((-1.0)*new_r01*x566);
evalcond[3]=(gconst4+((new_r01*x567)));
evalcond[4]=(x568+new_r01);
evalcond[5]=(x568+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x569=IKPowWithIntegerCheck(new_r01,-1);
if(!x569.valid){
continue;
}
cj16array[0]=((-1.0)*gconst4*(x569.value));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x570=IKsin(j16);
IkReal x571=IKcos(j16);
IkReal x572=(gconst4*x571);
evalcond[0]=(new_r10*x570);
evalcond[1]=(gconst4*x570);
evalcond[2]=((-1.0)*new_r01*x570);
evalcond[3]=(((new_r10*x571))+gconst4);
evalcond[4]=(x572+new_r01);
evalcond[5]=(x572+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst4;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[4];
CheckValue<IkReal> x574 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x574.valid){
continue;
}
IkReal x573=((1.0)*(x574.value));
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst4;
cj18=gconst5;
j18=((3.14159265)+(((-1.0)*x573)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst3=((3.14159265358979)+(((-1.0)*x573)));
IkReal gconst4=((1.0)*new_r01);
IkReal gconst5=((-1.0)*new_r11);
j16eval[0]=1.0;
j16eval[1]=1.0;
j16eval[2]=new_r01;
j16eval[3]=1.0;
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  || IKabs(j16eval[3]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
CheckValue<IkReal> x576 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x576.valid){
continue;
}
IkReal x575=((1.0)*(x576.value));
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst4;
cj18=gconst5;
j18=((3.14159265)+(((-1.0)*x575)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst3=((3.14159265358979)+(((-1.0)*x575)));
IkReal gconst4=((1.0)*new_r01);
IkReal gconst5=((-1.0)*new_r11);
j16eval[0]=-1.0;
j16eval[1]=((IKabs(((-1.0)+(new_r01*new_r01))))+(IKabs(((1.0)*new_r01*new_r11))));
j16eval[2]=-1.0;
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
CheckValue<IkReal> x578 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x578.valid){
continue;
}
IkReal x577=((1.0)*(x578.value));
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst4;
cj18=gconst5;
j18=((3.14159265)+(((-1.0)*x577)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst3=((3.14159265358979)+(((-1.0)*x577)));
IkReal gconst4=((1.0)*new_r01);
IkReal gconst5=((-1.0)*new_r11);
j16eval[0]=1.0;
j16eval[1]=((IKabs(((2.0)*new_r01*new_r11)))+(IKabs(((1.0)+(((-2.0)*(new_r01*new_r01)))))));
j16eval[2]=1.0;
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x579=((1.0)*new_r11);
CheckValue<IkReal> x580 = IKatan2WithCheck(IkReal((((gconst5*new_r01))+(((-1.0)*gconst4*x579)))),IkReal(((((-1.0)*gconst5*x579))+(((-1.0)*gconst4*new_r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x580.valid){
continue;
}
CheckValue<IkReal> x581=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x581.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x580.value)+(((1.5707963267949)*(x581.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x582=IKsin(j16);
IkReal x583=IKcos(j16);
IkReal x584=(gconst4*x583);
IkReal x585=(gconst5*x583);
IkReal x586=(gconst4*x582);
IkReal x587=((1.0)*x582);
IkReal x588=(gconst5*x587);
evalcond[0]=(gconst4+((new_r01*x583))+((new_r11*x582)));
evalcond[1]=(x585+x586+new_r11);
evalcond[2]=(x584+(((-1.0)*x588)));
evalcond[3]=((((-1.0)*new_r01*x587))+gconst5+((new_r11*x583)));
evalcond[4]=(x584+new_r01+(((-1.0)*x588)));
evalcond[5]=((((-1.0)*x585))+(((-1.0)*x586)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x589 = IKatan2WithCheck(IkReal((gconst4*new_r11)),IkReal((gconst5*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x589.valid){
continue;
}
CheckValue<IkReal> x590=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst4*gconst4)))+(((-1.0)*(gconst5*gconst5))))),-1);
if(!x590.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x589.value)+(((1.5707963267949)*(x590.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x591=IKsin(j16);
IkReal x592=IKcos(j16);
IkReal x593=(gconst4*x592);
IkReal x594=(gconst5*x592);
IkReal x595=(gconst4*x591);
IkReal x596=((1.0)*x591);
IkReal x597=(gconst5*x596);
evalcond[0]=(((new_r11*x591))+gconst4+((new_r01*x592)));
evalcond[1]=(x595+x594+new_r11);
evalcond[2]=((((-1.0)*x597))+x593);
evalcond[3]=(((new_r11*x592))+gconst5+(((-1.0)*new_r01*x596)));
evalcond[4]=((((-1.0)*x597))+x593+new_r01);
evalcond[5]=((((-1.0)*x595))+(((-1.0)*x594)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x598 = IKatan2WithCheck(IkReal((gconst4*gconst5)),IkReal(((-1.0)*(gconst4*gconst4))),IKFAST_ATAN2_MAGTHRESH);
if(!x598.valid){
continue;
}
CheckValue<IkReal> x599=IKPowWithIntegerCheck(IKsign((((gconst4*new_r01))+(((-1.0)*gconst5*new_r11)))),-1);
if(!x599.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x598.value)+(((1.5707963267949)*(x599.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x600=IKsin(j16);
IkReal x601=IKcos(j16);
IkReal x602=(gconst4*x601);
IkReal x603=(gconst5*x601);
IkReal x604=(gconst4*x600);
IkReal x605=((1.0)*x600);
IkReal x606=(gconst5*x605);
evalcond[0]=(gconst4+((new_r11*x600))+((new_r01*x601)));
evalcond[1]=(x603+x604+new_r11);
evalcond[2]=(x602+(((-1.0)*x606)));
evalcond[3]=(gconst5+((new_r11*x601))+(((-1.0)*new_r01*x605)));
evalcond[4]=(x602+(((-1.0)*x606))+new_r01);
evalcond[5]=((((-1.0)*x604))+(((-1.0)*x603)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x607=IKPowWithIntegerCheck(gconst5,-1);
if(!x607.valid){
continue;
}
cj16array[0]=(new_r00*(x607.value));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x608=IKsin(j16);
IkReal x609=IKcos(j16);
IkReal x610=((-1.0)*x608);
evalcond[0]=(new_r11*x608);
evalcond[1]=(new_r00*x610);
evalcond[2]=(gconst5*x610);
evalcond[3]=(((gconst5*x609))+new_r11);
evalcond[4]=(gconst5+((new_r11*x609)));
evalcond[5]=((((-1.0)*gconst5))+((new_r00*x609)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[1];
CheckValue<IkReal> x612 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x612.valid){
continue;
}
IkReal x611=((1.0)*(x612.value));
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst4;
cj18=gconst5;
j18=((3.14159265)+(((-1.0)*x611)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst3=((3.14159265358979)+(((-1.0)*x611)));
IkReal gconst4=0;
IkReal x613 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x613)==0){
continue;
}
IkReal gconst5=((-1.0)*new_r11*(pow(x613,-0.5)));
j16eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
CheckValue<IkReal> x615 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x615.valid){
continue;
}
IkReal x614=((1.0)*(x615.value));
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst4;
cj18=gconst5;
j18=((3.14159265)+(((-1.0)*x614)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst3=((3.14159265358979)+(((-1.0)*x614)));
IkReal gconst4=0;
IkReal x616 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x616)==0){
continue;
}
IkReal gconst5=((-1.0)*new_r11*(pow(x616,-0.5)));
j16eval[0]=new_r11;
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
CheckValue<IkReal> x618 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x618.valid){
continue;
}
IkReal x617=((1.0)*(x618.value));
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst4;
cj18=gconst5;
j18=((3.14159265)+(((-1.0)*x617)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst3=((3.14159265358979)+(((-1.0)*x617)));
IkReal gconst4=0;
IkReal x619 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x619)==0){
continue;
}
IkReal gconst5=((-1.0)*new_r11*(pow(x619,-0.5)));
j16eval[0]=new_r10;
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x620=IKPowWithIntegerCheck(new_r10,-1);
if(!x620.valid){
continue;
}
CheckValue<IkReal> x621=IKPowWithIntegerCheck(gconst5,-1);
if(!x621.valid){
continue;
}
if( IKabs((gconst5*(x620.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11*(x621.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst5*(x620.value)))+IKsqr(((-1.0)*new_r11*(x621.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2((gconst5*(x620.value)), ((-1.0)*new_r11*(x621.value)));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x622=IKsin(j16);
IkReal x623=IKcos(j16);
IkReal x624=((1.0)*gconst5);
IkReal x625=(gconst5*x623);
evalcond[0]=(new_r11*x622);
evalcond[1]=(new_r10*x623);
evalcond[2]=((-1.0)*gconst5*x622);
evalcond[3]=((-1.0)*x625);
evalcond[4]=(x625+new_r11);
evalcond[5]=(gconst5+((new_r11*x623)));
evalcond[6]=((((-1.0)*x622*x624))+new_r10);
evalcond[7]=((((-1.0)*x624))+((new_r10*x622)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x626=IKPowWithIntegerCheck(gconst5,-1);
if(!x626.valid){
continue;
}
CheckValue<IkReal> x627=IKPowWithIntegerCheck(new_r11,-1);
if(!x627.valid){
continue;
}
if( IKabs((new_r10*(x626.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst5*(x627.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x626.value)))+IKsqr(((-1.0)*gconst5*(x627.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2((new_r10*(x626.value)), ((-1.0)*gconst5*(x627.value)));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x628=IKsin(j16);
IkReal x629=IKcos(j16);
IkReal x630=((1.0)*gconst5);
IkReal x631=(gconst5*x629);
evalcond[0]=(new_r11*x628);
evalcond[1]=(new_r10*x629);
evalcond[2]=((-1.0)*gconst5*x628);
evalcond[3]=((-1.0)*x631);
evalcond[4]=(x631+new_r11);
evalcond[5]=(gconst5+((new_r11*x629)));
evalcond[6]=((((-1.0)*x628*x630))+new_r10);
evalcond[7]=((((-1.0)*x630))+((new_r10*x628)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x632 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x632.valid){
continue;
}
CheckValue<IkReal> x633=IKPowWithIntegerCheck(IKsign(gconst5),-1);
if(!x633.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x632.value)+(((1.5707963267949)*(x633.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x634=IKsin(j16);
IkReal x635=IKcos(j16);
IkReal x636=((1.0)*gconst5);
IkReal x637=(gconst5*x635);
evalcond[0]=(new_r11*x634);
evalcond[1]=(new_r10*x635);
evalcond[2]=((-1.0)*gconst5*x634);
evalcond[3]=((-1.0)*x637);
evalcond[4]=(x637+new_r11);
evalcond[5]=(gconst5+((new_r11*x635)));
evalcond[6]=((((-1.0)*x634*x636))+new_r10);
evalcond[7]=((((-1.0)*x636))+((new_r10*x634)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[1];
CheckValue<IkReal> x639 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x639.valid){
continue;
}
IkReal x638=((1.0)*(x639.value));
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst4;
cj18=gconst5;
j18=((3.14159265)+(((-1.0)*x638)));
new_r01=0;
IkReal gconst3=((3.14159265358979)+(((-1.0)*x638)));
IkReal gconst4=0;
IkReal x640 = new_r11*new_r11;
if(IKabs(x640)==0){
continue;
}
IkReal gconst5=((-1.0)*new_r11*(pow(x640,-0.5)));
j16eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
CheckValue<IkReal> x642 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x642.valid){
continue;
}
IkReal x641=((1.0)*(x642.value));
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst4;
cj18=gconst5;
j18=((3.14159265)+(((-1.0)*x641)));
new_r01=0;
IkReal gconst3=((3.14159265358979)+(((-1.0)*x641)));
IkReal gconst4=0;
IkReal x643 = new_r11*new_r11;
if(IKabs(x643)==0){
continue;
}
IkReal gconst5=((-1.0)*new_r11*(pow(x643,-0.5)));
j16eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
CheckValue<IkReal> x645 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x645.valid){
continue;
}
IkReal x644=((1.0)*(x645.value));
sj17=1.0;
cj17=0;
j17=1.5707963267949;
sj18=gconst4;
cj18=gconst5;
j18=((3.14159265)+(((-1.0)*x644)));
new_r01=0;
IkReal gconst3=((3.14159265358979)+(((-1.0)*x644)));
IkReal gconst4=0;
IkReal x646 = new_r11*new_r11;
if(IKabs(x646)==0){
continue;
}
IkReal gconst5=((-1.0)*new_r11*(pow(x646,-0.5)));
j16eval[0]=new_r11;
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x647=IKPowWithIntegerCheck(gconst5,-1);
if(!x647.valid){
continue;
}
CheckValue<IkReal> x648=IKPowWithIntegerCheck(new_r11,-1);
if(!x648.valid){
continue;
}
if( IKabs((new_r10*(x647.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst5*(x648.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x647.value)))+IKsqr(((-1.0)*gconst5*(x648.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2((new_r10*(x647.value)), ((-1.0)*gconst5*(x648.value)));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x649=IKsin(j16);
IkReal x650=IKcos(j16);
IkReal x651=((1.0)*gconst5);
IkReal x652=((1.0)*x649);
evalcond[0]=(new_r11*x649);
evalcond[1]=((-1.0)*gconst5*x649);
evalcond[2]=(new_r11+((gconst5*x650)));
evalcond[3]=(gconst5+((new_r11*x650)));
evalcond[4]=((((-1.0)*x649*x651))+new_r10);
evalcond[5]=((((-1.0)*x650*x651))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x652))+((new_r10*x650)));
evalcond[7]=((((-1.0)*x651))+((new_r10*x649))+((new_r00*x650)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x653 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x653.valid){
continue;
}
CheckValue<IkReal> x654=IKPowWithIntegerCheck(IKsign(gconst5),-1);
if(!x654.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x653.value)+(((1.5707963267949)*(x654.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x655=IKsin(j16);
IkReal x656=IKcos(j16);
IkReal x657=((1.0)*gconst5);
IkReal x658=((1.0)*x655);
evalcond[0]=(new_r11*x655);
evalcond[1]=((-1.0)*gconst5*x655);
evalcond[2]=(new_r11+((gconst5*x656)));
evalcond[3]=(gconst5+((new_r11*x656)));
evalcond[4]=((((-1.0)*x655*x657))+new_r10);
evalcond[5]=((((-1.0)*x656*x657))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x658))+((new_r10*x656)));
evalcond[7]=((((-1.0)*x657))+((new_r10*x655))+((new_r00*x656)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x659 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x659.valid){
continue;
}
CheckValue<IkReal> x660=IKPowWithIntegerCheck(IKsign(gconst5),-1);
if(!x660.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x659.value)+(((1.5707963267949)*(x660.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x661=IKsin(j16);
IkReal x662=IKcos(j16);
IkReal x663=((1.0)*gconst5);
IkReal x664=((1.0)*x661);
evalcond[0]=(new_r11*x661);
evalcond[1]=((-1.0)*gconst5*x661);
evalcond[2]=(((gconst5*x662))+new_r11);
evalcond[3]=(gconst5+((new_r11*x662)));
evalcond[4]=((((-1.0)*x661*x663))+new_r10);
evalcond[5]=((((-1.0)*x662*x663))+new_r00);
evalcond[6]=(((new_r10*x662))+(((-1.0)*new_r00*x664)));
evalcond[7]=(((new_r10*x661))+(((-1.0)*x663))+((new_r00*x662)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j16]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x665=((1.0)*new_r11);
CheckValue<IkReal> x666 = IKatan2WithCheck(IkReal((((gconst4*gconst5))+(((-1.0)*new_r01*x665)))),IkReal(((new_r11*new_r11)+(((-1.0)*(gconst4*gconst4))))),IKFAST_ATAN2_MAGTHRESH);
if(!x666.valid){
continue;
}
CheckValue<IkReal> x667=IKPowWithIntegerCheck(IKsign((((gconst4*new_r01))+(((-1.0)*gconst5*x665)))),-1);
if(!x667.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x666.value)+(((1.5707963267949)*(x667.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x668=IKsin(j16);
IkReal x669=IKcos(j16);
IkReal x670=((1.0)*gconst5);
IkReal x671=(gconst4*x669);
IkReal x672=((1.0)*x668);
IkReal x673=(x668*x670);
evalcond[0]=(gconst4+((new_r11*x668))+((new_r01*x669)));
evalcond[1]=(((gconst5*x669))+((gconst4*x668))+new_r11);
evalcond[2]=((((-1.0)*new_r00*x672))+gconst4+((new_r10*x669)));
evalcond[3]=((((-1.0)*new_r01*x672))+gconst5+((new_r11*x669)));
evalcond[4]=(x671+new_r01+(((-1.0)*x673)));
evalcond[5]=(x671+new_r10+(((-1.0)*x673)));
evalcond[6]=(((new_r10*x668))+((new_r00*x669))+(((-1.0)*x670)));
evalcond[7]=((((-1.0)*gconst4*x672))+(((-1.0)*x669*x670))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x674=((1.0)*new_r11);
CheckValue<IkReal> x675 = IKatan2WithCheck(IkReal((((gconst5*new_r01))+(((-1.0)*gconst4*x674)))),IkReal(((((-1.0)*gconst5*x674))+(((-1.0)*gconst4*new_r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x675.valid){
continue;
}
CheckValue<IkReal> x676=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x676.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x675.value)+(((1.5707963267949)*(x676.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x677=IKsin(j16);
IkReal x678=IKcos(j16);
IkReal x679=((1.0)*gconst5);
IkReal x680=(gconst4*x678);
IkReal x681=((1.0)*x677);
IkReal x682=(x677*x679);
evalcond[0]=(((new_r11*x677))+((new_r01*x678))+gconst4);
evalcond[1]=(((gconst5*x678))+((gconst4*x677))+new_r11);
evalcond[2]=(((new_r10*x678))+gconst4+(((-1.0)*new_r00*x681)));
evalcond[3]=(((new_r11*x678))+(((-1.0)*new_r01*x681))+gconst5);
evalcond[4]=((((-1.0)*x682))+x680+new_r01);
evalcond[5]=((((-1.0)*x682))+x680+new_r10);
evalcond[6]=(((new_r00*x678))+((new_r10*x677))+(((-1.0)*x679)));
evalcond[7]=((((-1.0)*x678*x679))+new_r00+(((-1.0)*gconst4*x681)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x683=((1.0)*gconst4);
CheckValue<IkReal> x684=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x684.valid){
continue;
}
CheckValue<IkReal> x685 = IKatan2WithCheck(IkReal(((((-1.0)*new_r10*x683))+((gconst4*new_r01)))),IkReal(((((-1.0)*new_r11*x683))+(((-1.0)*new_r00*x683)))),IKFAST_ATAN2_MAGTHRESH);
if(!x685.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x684.value)))+(x685.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x686=IKsin(j16);
IkReal x687=IKcos(j16);
IkReal x688=((1.0)*gconst5);
IkReal x689=(gconst4*x687);
IkReal x690=((1.0)*x686);
IkReal x691=(x686*x688);
evalcond[0]=(gconst4+((new_r01*x687))+((new_r11*x686)));
evalcond[1]=(((gconst5*x687))+((gconst4*x686))+new_r11);
evalcond[2]=(gconst4+(((-1.0)*new_r00*x690))+((new_r10*x687)));
evalcond[3]=((((-1.0)*new_r01*x690))+gconst5+((new_r11*x687)));
evalcond[4]=(x689+(((-1.0)*x691))+new_r01);
evalcond[5]=(x689+(((-1.0)*x691))+new_r10);
evalcond[6]=((((-1.0)*x688))+((new_r00*x687))+((new_r10*x686)));
evalcond[7]=((((-1.0)*x687*x688))+(((-1.0)*gconst4*x690))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((new_r01*new_r01)+(new_r11*new_r11));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[1];
sj17=1.0;
cj17=0;
j17=1.5707963267949;
new_r01=0;
new_r11=0;
j16eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x693 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x693.valid){
continue;
}
IkReal x692=x693.value;
j16array[0]=((-1.0)*x692);
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
j16array[1]=((3.14159265358979)+(((-1.0)*x692)));
sj16array[1]=IKsin(j16array[1]);
cj16array[1]=IKcos(j16array[1]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
if( j16array[1] > IKPI )
{
    j16array[1]-=IK2PI;
}
else if( j16array[1] < -IKPI )
{    j16array[1]+=IK2PI;
}
j16valid[1] = true;
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[1];
evalcond[0]=(((new_r10*(IKcos(j16))))+(((-1.0)*new_r00*(IKsin(j16)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j18))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x694=IKcos(j16);
IkReal x695=IKsin(j16);
IkReal x696=((1.0)*x695);
evalcond[0]=(x694+new_r11);
evalcond[1]=((((-1.0)*x696))+new_r01);
evalcond[2]=((((-1.0)*x696))+new_r10);
evalcond[3]=(new_r00+(((-1.0)*x694)));
evalcond[4]=(((new_r11*x695))+((new_r01*x694)));
evalcond[5]=((-1.0)+((new_r10*x695))+((new_r00*x694)));
evalcond[6]=(((new_r10*x694))+(((-1.0)*new_r00*x696)));
evalcond[7]=((1.0)+(((-1.0)*new_r01*x696))+((new_r11*x694)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j18)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-1.0)*new_r01), ((-1.0)*new_r00));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x697=IKsin(j16);
IkReal x698=IKcos(j16);
IkReal x699=((1.0)*x697);
evalcond[0]=(x697+new_r01);
evalcond[1]=(x697+new_r10);
evalcond[2]=(x698+new_r00);
evalcond[3]=(new_r11+(((-1.0)*x698)));
evalcond[4]=(((new_r11*x697))+((new_r01*x698)));
evalcond[5]=((1.0)+((new_r10*x697))+((new_r00*x698)));
evalcond[6]=(((new_r10*x698))+(((-1.0)*new_r00*x699)));
evalcond[7]=((-1.0)+(((-1.0)*new_r01*x699))+((new_r11*x698)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[3];
sj17=1.0;
cj17=0;
j17=1.5707963267949;
new_r11=0;
new_r00=0;
j16eval[0]=new_r01;
j16eval[1]=IKsign(new_r01);
j16eval[2]=((IKabs(sj18))+(IKabs(cj18)));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[2];
sj17=1.0;
cj17=0;
j17=1.5707963267949;
new_r11=0;
new_r00=0;
j16eval[0]=new_r01;
j16eval[1]=new_r10;
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j16]

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x700=IKPowWithIntegerCheck(new_r01,-1);
if(!x700.valid){
continue;
}
CheckValue<IkReal> x701=IKPowWithIntegerCheck(new_r10,-1);
if(!x701.valid){
continue;
}
if( IKabs((cj18*(x700.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*sj18*(x701.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((cj18*(x700.value)))+IKsqr(((-1.0)*sj18*(x701.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2((cj18*(x700.value)), ((-1.0)*sj18*(x701.value)));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[7];
IkReal x702=IKcos(j16);
IkReal x703=IKsin(j16);
IkReal x704=(sj18*x702);
IkReal x705=((1.0)*x703);
IkReal x706=(cj18*x705);
evalcond[0]=(((new_r01*x702))+sj18);
evalcond[1]=(sj18+((new_r10*x702)));
evalcond[2]=(cj18+(((-1.0)*new_r01*x705)));
evalcond[3]=((((-1.0)*cj18))+((new_r10*x703)));
evalcond[4]=(((cj18*x702))+((sj18*x703)));
evalcond[5]=((((-1.0)*x706))+x704+new_r01);
evalcond[6]=((((-1.0)*x706))+x704+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x707=IKPowWithIntegerCheck(IKsign(new_r01),-1);
if(!x707.valid){
continue;
}
CheckValue<IkReal> x708 = IKatan2WithCheck(IkReal(cj18),IkReal(((-1.0)*sj18)),IKFAST_ATAN2_MAGTHRESH);
if(!x708.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x707.value)))+(x708.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[7];
IkReal x709=IKcos(j16);
IkReal x710=IKsin(j16);
IkReal x711=(sj18*x709);
IkReal x712=((1.0)*x710);
IkReal x713=(cj18*x712);
evalcond[0]=(((new_r01*x709))+sj18);
evalcond[1]=(sj18+((new_r10*x709)));
evalcond[2]=(cj18+(((-1.0)*new_r01*x712)));
evalcond[3]=((((-1.0)*cj18))+((new_r10*x710)));
evalcond[4]=(((sj18*x710))+((cj18*x709)));
evalcond[5]=((((-1.0)*x713))+x711+new_r01);
evalcond[6]=((((-1.0)*x713))+x711+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[1];
sj17=1.0;
cj17=0;
j17=1.5707963267949;
new_r11=0;
new_r01=0;
new_r22=0;
new_r20=0;
j16eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j16]

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x715 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x715.valid){
continue;
}
IkReal x714=x715.value;
j16array[0]=((-1.0)*x714);
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
j16array[1]=((3.14159265358979)+(((-1.0)*x714)));
sj16array[1]=IKsin(j16array[1]);
cj16array[1]=IKcos(j16array[1]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
if( j16array[1] > IKPI )
{
    j16array[1]-=IK2PI;
}
else if( j16array[1] < -IKPI )
{    j16array[1]+=IK2PI;
}
j16valid[1] = true;
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[1];
evalcond[0]=(((new_r10*(IKcos(j16))))+(((-1.0)*new_r00*(IKsin(j16)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[1];
sj17=1.0;
cj17=0;
j17=1.5707963267949;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
j16eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j16]

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x717 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x717.valid){
continue;
}
IkReal x716=x717.value;
j16array[0]=((-1.0)*x716);
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
j16array[1]=((3.14159265358979)+(((-1.0)*x716)));
sj16array[1]=IKsin(j16array[1]);
cj16array[1]=IKcos(j16array[1]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
if( j16array[1] > IKPI )
{
    j16array[1]-=IK2PI;
}
else if( j16array[1] < -IKPI )
{    j16array[1]+=IK2PI;
}
j16valid[1] = true;
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[1];
evalcond[0]=(((new_r11*(IKcos(j16))))+(((-1.0)*new_r01*(IKsin(j16)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[3];
sj17=1.0;
cj17=0;
j17=1.5707963267949;
new_r01=0;
new_r10=0;
j16eval[0]=new_r11;
j16eval[1]=IKsign(new_r11);
j16eval[2]=((IKabs(sj18))+(IKabs(cj18)));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[2];
sj17=1.0;
cj17=0;
j17=1.5707963267949;
new_r01=0;
new_r10=0;
j16eval[0]=new_r00;
j16eval[1]=new_r11;
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )
{
{
IkReal j16eval[2];
sj17=1.0;
cj17=0;
j17=1.5707963267949;
new_r01=0;
new_r10=0;
j16eval[0]=new_r11;
j16eval[1]=cj18;
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j18)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
sj16array[0]=new_r00;
if( sj16array[0] >= -1-IKFAST_SINCOS_THRESH && sj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKasin(sj16array[0]);
    cj16array[0] = IKcos(j16array[0]);
    sj16array[1] = sj16array[0];
    j16array[1] = j16array[0] > 0 ? (IKPI-j16array[0]) : (-IKPI-j16array[0]);
    cj16array[1] = -cj16array[0];
}
else if( isnan(sj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x718=IKcos(j16);
IkReal x719=IKsin(j16);
evalcond[0]=x718;
evalcond[1]=(new_r00*x718);
evalcond[2]=(x719+new_r11);
evalcond[3]=(new_r11*x718);
evalcond[4]=((1.0)+((new_r11*x719)));
evalcond[5]=((1.0)+(((-1.0)*new_r00*x719)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j18)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
sj16array[0]=new_r11;
if( sj16array[0] >= -1-IKFAST_SINCOS_THRESH && sj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKasin(sj16array[0]);
    cj16array[0] = IKcos(j16array[0]);
    sj16array[1] = sj16array[0];
    j16array[1] = j16array[0] > 0 ? (IKPI-j16array[0]) : (-IKPI-j16array[0]);
    cj16array[1] = -cj16array[0];
}
else if( isnan(sj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x720=IKcos(j16);
IkReal x721=IKsin(j16);
evalcond[0]=(new_r00*x720);
evalcond[1]=(new_r11*x720);
evalcond[2]=((-1.0)*x720);
evalcond[3]=(x721+new_r00);
evalcond[4]=((-1.0)+((new_r11*x721)));
evalcond[5]=((-1.0)+(((-1.0)*new_r00*x721)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j16]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x723=IKPowWithIntegerCheck(new_r11,-1);
if(!x723.valid){
continue;
}
IkReal x722=x723.value;
CheckValue<IkReal> x724=IKPowWithIntegerCheck(cj18,-1);
if(!x724.valid){
continue;
}
CheckValue<IkReal> x725=IKPowWithIntegerCheck(x722,-2);
if(!x725.valid){
continue;
}
if( IKabs(((-1.0)*sj18*x722)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x722*(x724.value)*(((1.0)+(((-1.0)*(x725.value)))+(((-1.0)*(cj18*cj18))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*sj18*x722))+IKsqr((x722*(x724.value)*(((1.0)+(((-1.0)*(x725.value)))+(((-1.0)*(cj18*cj18)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-1.0)*sj18*x722), (x722*(x724.value)*(((1.0)+(((-1.0)*(x725.value)))+(((-1.0)*(cj18*cj18)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[7];
IkReal x726=IKsin(j16);
IkReal x727=IKcos(j16);
IkReal x728=((1.0)*cj18);
IkReal x729=((1.0)*x726);
evalcond[0]=(sj18+((new_r11*x726)));
evalcond[1]=(cj18+((new_r11*x727)));
evalcond[2]=(sj18+(((-1.0)*new_r00*x729)));
evalcond[3]=(((new_r00*x727))+(((-1.0)*x728)));
evalcond[4]=(((cj18*x727))+new_r11+((sj18*x726)));
evalcond[5]=((((-1.0)*x726*x728))+((sj18*x727)));
evalcond[6]=((((-1.0)*x727*x728))+(((-1.0)*sj18*x729))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x730=IKPowWithIntegerCheck(new_r00,-1);
if(!x730.valid){
continue;
}
CheckValue<IkReal> x731=IKPowWithIntegerCheck(new_r11,-1);
if(!x731.valid){
continue;
}
if( IKabs((sj18*(x730.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*cj18*(x731.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((sj18*(x730.value)))+IKsqr(((-1.0)*cj18*(x731.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2((sj18*(x730.value)), ((-1.0)*cj18*(x731.value)));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[7];
IkReal x732=IKsin(j16);
IkReal x733=IKcos(j16);
IkReal x734=((1.0)*cj18);
IkReal x735=((1.0)*x732);
evalcond[0]=(sj18+((new_r11*x732)));
evalcond[1]=(cj18+((new_r11*x733)));
evalcond[2]=(sj18+(((-1.0)*new_r00*x735)));
evalcond[3]=(((new_r00*x733))+(((-1.0)*x734)));
evalcond[4]=(((cj18*x733))+((sj18*x732))+new_r11);
evalcond[5]=((((-1.0)*x732*x734))+((sj18*x733)));
evalcond[6]=((((-1.0)*sj18*x735))+(((-1.0)*x733*x734))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x736=IKPowWithIntegerCheck(IKsign(new_r11),-1);
if(!x736.valid){
continue;
}
CheckValue<IkReal> x737 = IKatan2WithCheck(IkReal(((-1.0)*sj18)),IkReal(((-1.0)*cj18)),IKFAST_ATAN2_MAGTHRESH);
if(!x737.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x736.value)))+(x737.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[7];
IkReal x738=IKsin(j16);
IkReal x739=IKcos(j16);
IkReal x740=((1.0)*cj18);
IkReal x741=((1.0)*x738);
evalcond[0]=(sj18+((new_r11*x738)));
evalcond[1]=(cj18+((new_r11*x739)));
evalcond[2]=((((-1.0)*new_r00*x741))+sj18);
evalcond[3]=(((new_r00*x739))+(((-1.0)*x740)));
evalcond[4]=(((cj18*x739))+((sj18*x738))+new_r11);
evalcond[5]=((((-1.0)*x738*x740))+((sj18*x739)));
evalcond[6]=((((-1.0)*sj18*x741))+(((-1.0)*x739*x740))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j16]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x742 = IKatan2WithCheck(IkReal(((-1.0)+(new_r01*new_r01)+(cj18*cj18))),IkReal(((((-1.0)*new_r01*new_r11))+(((-1.0)*cj18*sj18)))),IKFAST_ATAN2_MAGTHRESH);
if(!x742.valid){
continue;
}
CheckValue<IkReal> x743=IKPowWithIntegerCheck(IKsign((((cj18*new_r01))+((new_r11*sj18)))),-1);
if(!x743.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x742.value)+(((1.5707963267949)*(x743.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x744=IKcos(j16);
IkReal x745=IKsin(j16);
IkReal x746=(sj18*x744);
IkReal x747=((1.0)*x745);
IkReal x748=(cj18*x744);
IkReal x749=(cj18*x747);
evalcond[0]=(sj18+((new_r01*x744))+((new_r11*x745)));
evalcond[1]=(((sj18*x745))+x748+new_r11);
evalcond[2]=((((-1.0)*new_r00*x747))+sj18+((new_r10*x744)));
evalcond[3]=((((-1.0)*new_r01*x747))+cj18+((new_r11*x744)));
evalcond[4]=(x746+new_r01+(((-1.0)*x749)));
evalcond[5]=(x746+new_r10+(((-1.0)*x749)));
evalcond[6]=(((new_r10*x745))+((new_r00*x744))+(((-1.0)*cj18)));
evalcond[7]=((((-1.0)*sj18*x747))+(((-1.0)*x748))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x750=((1.0)*sj18);
CheckValue<IkReal> x751=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x751.valid){
continue;
}
CheckValue<IkReal> x752 = IKatan2WithCheck(IkReal(((((-1.0)*new_r11*x750))+((cj18*new_r01)))),IkReal(((((-1.0)*new_r01*x750))+(((-1.0)*cj18*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x752.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x751.value)))+(x752.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x753=IKcos(j16);
IkReal x754=IKsin(j16);
IkReal x755=(sj18*x753);
IkReal x756=((1.0)*x754);
IkReal x757=(cj18*x753);
IkReal x758=(cj18*x756);
evalcond[0]=(((new_r11*x754))+sj18+((new_r01*x753)));
evalcond[1]=(((sj18*x754))+x757+new_r11);
evalcond[2]=((((-1.0)*new_r00*x756))+sj18+((new_r10*x753)));
evalcond[3]=((((-1.0)*new_r01*x756))+((new_r11*x753))+cj18);
evalcond[4]=(x755+new_r01+(((-1.0)*x758)));
evalcond[5]=(x755+new_r10+(((-1.0)*x758)));
evalcond[6]=(((new_r00*x753))+((new_r10*x754))+(((-1.0)*cj18)));
evalcond[7]=((((-1.0)*sj18*x756))+(((-1.0)*x757))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x759=((1.0)*sj18);
CheckValue<IkReal> x760 = IKatan2WithCheck(IkReal(((((-1.0)*new_r10*x759))+((new_r01*sj18)))),IkReal(((((-1.0)*new_r00*x759))+(((-1.0)*new_r11*x759)))),IKFAST_ATAN2_MAGTHRESH);
if(!x760.valid){
continue;
}
CheckValue<IkReal> x761=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x761.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x760.value)+(((1.5707963267949)*(x761.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x762=IKcos(j16);
IkReal x763=IKsin(j16);
IkReal x764=(sj18*x762);
IkReal x765=((1.0)*x763);
IkReal x766=(cj18*x762);
IkReal x767=(cj18*x765);
evalcond[0]=(((new_r11*x763))+((new_r01*x762))+sj18);
evalcond[1]=(((sj18*x763))+x766+new_r11);
evalcond[2]=(((new_r10*x762))+(((-1.0)*new_r00*x765))+sj18);
evalcond[3]=(((new_r11*x762))+cj18+(((-1.0)*new_r01*x765)));
evalcond[4]=((((-1.0)*x767))+x764+new_r01);
evalcond[5]=((((-1.0)*x767))+x764+new_r10);
evalcond[6]=(((new_r10*x763))+((new_r00*x762))+(((-1.0)*cj18)));
evalcond[7]=((((-1.0)*x766))+(((-1.0)*sj18*x765))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x768=((1.0)*sj18);
if( IKabs(((((-1.0)*cj18*new_r01))+(((-1.0)*new_r11*x768)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj18*new_r11))+(((-1.0)*new_r01*x768)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj18*new_r01))+(((-1.0)*new_r11*x768))))+IKsqr((((cj18*new_r11))+(((-1.0)*new_r01*x768))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((((-1.0)*cj18*new_r01))+(((-1.0)*new_r11*x768))), (((cj18*new_r11))+(((-1.0)*new_r01*x768))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[8];
IkReal x769=IKsin(j16);
IkReal x770=IKcos(j16);
IkReal x771=((1.0)*cj18);
IkReal x772=((1.0)*sj18);
IkReal x773=(sj18*x769);
IkReal x774=((1.0)*x769);
IkReal x775=(x770*x771);
evalcond[0]=(((new_r11*x769))+sj18+((new_r01*x770)));
evalcond[1]=(((sj18*x770))+((cj18*x769))+new_r01);
evalcond[2]=(x773+(((-1.0)*x775))+new_r11);
evalcond[3]=(x773+(((-1.0)*x775))+new_r00);
evalcond[4]=(((new_r10*x769))+((new_r00*x770))+(((-1.0)*x771)));
evalcond[5]=((((-1.0)*x769*x771))+new_r10+(((-1.0)*x770*x772)));
evalcond[6]=((((-1.0)*new_r00*x774))+((new_r10*x770))+(((-1.0)*x772)));
evalcond[7]=((((-1.0)*new_r01*x774))+((new_r11*x770))+(((-1.0)*x771)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j16eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j16eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j16eval[0]=((IKabs((new_r10*new_r22)))+(IKabs((new_r00*new_r22))));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j16]

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x777 = IKatan2WithCheck(IkReal((new_r10*new_r22)),IkReal(((-1.0)*new_r00*new_r22)),IKFAST_ATAN2_MAGTHRESH);
if(!x777.valid){
continue;
}
IkReal x776=x777.value;
j16array[0]=((-1.0)*x776);
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
j16array[1]=((3.14159265358979)+(((-1.0)*x776)));
sj16array[1]=IKsin(j16array[1]);
cj16array[1]=IKcos(j16array[1]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
if( j16array[1] > IKPI )
{
    j16array[1]-=IK2PI;
}
else if( j16array[1] < -IKPI )
{    j16array[1]+=IK2PI;
}
j16valid[1] = true;
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x778=IKcos(j16);
IkReal x779=IKsin(j16);
IkReal x780=((1.0)*x779);
IkReal x781=(new_r11*x778);
evalcond[0]=(((new_r11*x779))+((new_r01*x778)));
evalcond[1]=(((new_r00*x778))+((new_r10*x779)));
evalcond[2]=(((new_r10*x778))+(((-1.0)*new_r00*x780)));
evalcond[3]=((((-1.0)*new_r01*x780))+x781);
evalcond[4]=(((new_r22*x781))+(((-1.0)*new_r01*new_r22*x780)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x783 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x783.valid){
continue;
}
IkReal x782=x783.value;
j16array[0]=((-1.0)*x782);
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
j16array[1]=((3.14159265358979)+(((-1.0)*x782)));
sj16array[1]=IKsin(j16array[1]);
cj16array[1]=IKcos(j16array[1]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
if( j16array[1] > IKPI )
{
    j16array[1]-=IK2PI;
}
else if( j16array[1] < -IKPI )
{    j16array[1]+=IK2PI;
}
j16valid[1] = true;
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x784=IKcos(j16);
IkReal x785=IKsin(j16);
IkReal x786=(new_r22*x784);
IkReal x787=((1.0)*new_r00*x785);
IkReal x788=((1.0)*new_r01*x785);
evalcond[0]=(((new_r11*x785))+((new_r01*x784)));
evalcond[1]=(((new_r10*x784))+(((-1.0)*x787)));
evalcond[2]=((((-1.0)*x788))+((new_r11*x784)));
evalcond[3]=((((-1.0)*new_r22*x787))+((new_r10*x786)));
evalcond[4]=((((-1.0)*new_r22*x788))+((new_r11*x786)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x790 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x790.valid){
continue;
}
IkReal x789=x790.value;
j16array[0]=((-1.0)*x789);
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
j16array[1]=((3.14159265358979)+(((-1.0)*x789)));
sj16array[1]=IKsin(j16array[1]);
cj16array[1]=IKcos(j16array[1]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
if( j16array[1] > IKPI )
{
    j16array[1]-=IK2PI;
}
else if( j16array[1] < -IKPI )
{    j16array[1]+=IK2PI;
}
j16valid[1] = true;
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x791=IKcos(j16);
IkReal x792=IKsin(j16);
IkReal x793=((1.0)*x792);
IkReal x794=(new_r22*x791);
evalcond[0]=(((new_r10*x792))+((new_r00*x791)));
evalcond[1]=(((new_r10*x791))+(((-1.0)*new_r00*x793)));
evalcond[2]=((((-1.0)*new_r01*x793))+((new_r11*x791)));
evalcond[3]=(((new_r10*x794))+(((-1.0)*new_r00*new_r22*x793)));
evalcond[4]=(((new_r11*x794))+(((-1.0)*new_r01*new_r22*x793)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j16]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x796=IKPowWithIntegerCheck(cj17,-1);
if(!x796.valid){
continue;
}
IkReal x795=x796.value;
CheckValue<IkReal> x797=IKPowWithIntegerCheck(new_r11,-1);
if(!x797.valid){
continue;
}
if( IKabs((x795*(x797.value)*(((((-1.0)*cj17*sj18))+((new_r01*new_r12)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r12*x795)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x795*(x797.value)*(((((-1.0)*cj17*sj18))+((new_r01*new_r12))))))+IKsqr(((-1.0)*new_r12*x795))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2((x795*(x797.value)*(((((-1.0)*cj17*sj18))+((new_r01*new_r12))))), ((-1.0)*new_r12*x795));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[18];
IkReal x798=IKcos(j16);
IkReal x799=IKsin(j16);
IkReal x800=((1.0)*cj18);
IkReal x801=((1.0)*cj17);
IkReal x802=(cj18*sj17);
IkReal x803=(sj17*sj18);
IkReal x804=(new_r10*x798);
IkReal x805=(new_r01*x799);
IkReal x806=(new_r00*x799);
IkReal x807=((1.0)*x799);
IkReal x808=(new_r12*x798);
IkReal x809=(sj18*x798);
IkReal x810=(cj17*x798);
IkReal x811=(new_r02*x799);
IkReal x812=((1.0)*sj17*x798);
evalcond[0]=(new_r12+x810);
evalcond[1]=((((-1.0)*x799*x801))+new_r02);
evalcond[2]=(((new_r12*x799))+((new_r02*x798)));
evalcond[3]=(((new_r11*x799))+sj18+((new_r01*x798)));
evalcond[4]=((((-1.0)*new_r02*x807))+cj17+x808);
evalcond[5]=(((sj18*x799))+((x798*x802))+new_r11);
evalcond[6]=(((new_r10*x799))+((new_r00*x798))+(((-1.0)*x800)));
evalcond[7]=((((-1.0)*sj17*x799*x800))+new_r01+x809);
evalcond[8]=((((-1.0)*x799*x800))+((x798*x803))+new_r10);
evalcond[9]=((((-1.0)*x806))+x804+x803);
evalcond[10]=((((-1.0)*x805))+((new_r11*x798))+x802);
evalcond[11]=((((-1.0)*x798*x800))+(((-1.0)*x803*x807))+new_r00);
evalcond[12]=((((-1.0)*x801*x806))+((cj17*x804))+((new_r20*sj17)));
evalcond[13]=(((new_r11*x810))+((new_r21*sj17))+(((-1.0)*x801*x805)));
evalcond[14]=(((sj17*x811))+(((-1.0)*sj17*x808))+((cj17*new_r22)));
evalcond[15]=((1.0)+(((-1.0)*x801*x811))+((new_r22*sj17))+((cj17*x808)));
evalcond[16]=((((-1.0)*sj17*x804))+((cj17*new_r20))+((sj17*x806))+(((-1.0)*sj18)));
evalcond[17]=((((-1.0)*new_r11*x812))+((cj17*new_r21))+((sj17*x805))+(((-1.0)*x800)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
CheckValue<IkReal> x813=IKPowWithIntegerCheck(IKsign(cj17),-1);
if(!x813.valid){
continue;
}
CheckValue<IkReal> x814 = IKatan2WithCheck(IkReal(new_r02),IkReal(((-1.0)*new_r12)),IKFAST_ATAN2_MAGTHRESH);
if(!x814.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x813.value)))+(x814.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[18];
IkReal x815=IKcos(j16);
IkReal x816=IKsin(j16);
IkReal x817=((1.0)*cj18);
IkReal x818=((1.0)*cj17);
IkReal x819=(cj18*sj17);
IkReal x820=(sj17*sj18);
IkReal x821=(new_r10*x815);
IkReal x822=(new_r01*x816);
IkReal x823=(new_r00*x816);
IkReal x824=((1.0)*x816);
IkReal x825=(new_r12*x815);
IkReal x826=(sj18*x815);
IkReal x827=(cj17*x815);
IkReal x828=(new_r02*x816);
IkReal x829=((1.0)*sj17*x815);
evalcond[0]=(new_r12+x827);
evalcond[1]=((((-1.0)*x816*x818))+new_r02);
evalcond[2]=(((new_r12*x816))+((new_r02*x815)));
evalcond[3]=(((new_r11*x816))+((new_r01*x815))+sj18);
evalcond[4]=(cj17+(((-1.0)*new_r02*x824))+x825);
evalcond[5]=(((x815*x819))+((sj18*x816))+new_r11);
evalcond[6]=(((new_r00*x815))+((new_r10*x816))+(((-1.0)*x817)));
evalcond[7]=((((-1.0)*sj17*x816*x817))+new_r01+x826);
evalcond[8]=((((-1.0)*x816*x817))+((x815*x820))+new_r10);
evalcond[9]=((((-1.0)*x823))+x821+x820);
evalcond[10]=(((new_r11*x815))+(((-1.0)*x822))+x819);
evalcond[11]=((((-1.0)*x815*x817))+(((-1.0)*x820*x824))+new_r00);
evalcond[12]=((((-1.0)*x818*x823))+((cj17*x821))+((new_r20*sj17)));
evalcond[13]=((((-1.0)*x818*x822))+((new_r11*x827))+((new_r21*sj17)));
evalcond[14]=(((sj17*x828))+((cj17*new_r22))+(((-1.0)*sj17*x825)));
evalcond[15]=((1.0)+(((-1.0)*x818*x828))+((cj17*x825))+((new_r22*sj17)));
evalcond[16]=(((sj17*x823))+((cj17*new_r20))+(((-1.0)*sj18))+(((-1.0)*sj17*x821)));
evalcond[17]=(((sj17*x822))+((cj17*new_r21))+(((-1.0)*x817))+(((-1.0)*new_r11*x829)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j16;
vinfos[0].indices[0] = _ij16[0];
vinfos[0].indices[1] = _ij16[1];
vinfos[0].maxsolutions = _nj16;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j17;
vinfos[1].indices[0] = _ij17[0];
vinfos[1].indices[1] = _ij17[1];
vinfos[1].maxsolutions = _nj17;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j18;
vinfos[2].indices[0] = _ij18[0];
vinfos[2].indices[1] = _ij18[1];
vinfos[2].maxsolutions = _nj18;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j19;
vinfos[3].indices[0] = _ij19[0];
vinfos[3].indices[1] = _ij19[1];
vinfos[3].maxsolutions = _nj19;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j20;
vinfos[4].indices[0] = _ij20[0];
vinfos[4].indices[1] = _ij20[1];
vinfos[4].maxsolutions = _nj20;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j21;
vinfos[5].indices[0] = _ij21[0];
vinfos[5].indices[1] = _ij21[1];
vinfos[5].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - HRP2 (e9e649316be16b18c0b2e71568ebd572)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
